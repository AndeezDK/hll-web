<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stats - HLL Tool v0.6.10</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 16px;
        }
        
        /* Award cards grid */
        .awards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }
        .award-card {
            background: var(--bg-secondary); border: 1px solid var(--border-color);
            border-radius: 8px; padding: 12px; transition: border-color 0.2s;
        }
        .award-card:hover { border-color: var(--accent-orange); }
        .award-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .award-title { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .award-icon { font-size: 16px; }
        .award-winner { font-size: 15px; font-weight: 700; color: var(--text-primary); margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .award-stat { font-size: 12px; color: var(--text-secondary); }
        .award-stat .highlight { color: var(--accent-green); font-weight: 600; }
        .award-empty { font-size: 12px; color: var(--text-muted); font-style: italic; }
        .award-expand { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 10px; padding: 2px 0; margin-top: 6px; transition: color 0.15s; }
        .award-expand:hover { color: var(--accent-orange); }
        .award-runners { display: none; margin-top: 6px; border-top: 1px solid var(--border-color); padding-top: 6px; }
        .award-runners.visible { display: block; }
        .runner-row { display: flex; justify-content: space-between; padding: 2px 0; font-size: 11px; }
        .runner-rank { color: var(--text-muted); width: 18px; }
        .runner-name { flex: 1; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .runner-stat { color: var(--text-muted); margin-left: 8px; }
        
        .section-title {
            font-size: 16px; font-weight: 700; color: var(--text-primary);
            margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color);
        }
        
        .win-bar {
            display: flex;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            background: var(--bg-tertiary);
            margin-top: 4px;
        }
        
        .win-bar-fill {
            background: var(--accent-green);
            transition: width 0.3s ease;
        }
        
        .faction-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .faction-allies {
            background: rgba(56, 139, 253, 0.2);
            color: var(--accent-blue);
        }
        
        .faction-axis {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }
        
        .map-row {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .map-row:last-child {
            border-bottom: none;
        }
        
        .map-name {
            flex: 1;
            font-weight: 500;
        }
        
        .map-stats {
            display: flex;
            gap: 16px;
            align-items: center;
        }
        
        .map-record {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 60px;
            text-align: center;
        }
        
        .map-winrate {
            font-weight: 700;
            min-width: 50px;
            text-align: right;
        }
        
        .enemy-row {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .enemy-row:last-child {
            border-bottom: none;
        }
        
        .enemy-name {
            flex: 1;
            font-weight: 500;
        }
        
        .enemy-stats {
            display: flex;
            gap: 24px;
            align-items: center;
        }
        
        .points-diff {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .points-diff.positive {
            background: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }
        
        .points-diff.negative {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }
        
        .role-bar-row {
            display: flex;
            align-items: center;
            padding: 6px 0;
            gap: 10px;
        }
        
        .role-bar-label {
            min-width: 90px;
            font-size: 13px;
            font-weight: 500;
        }
        
        .role-bar-track {
            flex: 1;
            height: 14px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .role-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .role-bar-value {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        /* Form dots */
        .form-dots { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
        .form-dot {
            width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 11px; font-weight: 700; color: #fff;
        }
        .form-dot.W { background: var(--accent-green); }
        .form-dot.L { background: var(--accent-red); }
        .form-dot.D { background: var(--text-muted); }
        
        /* Streak cards */
        .streak-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px;
        }
        .streak-card {
            background: var(--bg-tertiary); border-radius: 6px; padding: 10px; text-align: center;
        }
        .streak-value { font-size: 1.3rem; font-weight: 700; }
        .streak-label { font-size: 11px; color: var(--text-muted); margin-top: 2px; }
        
        /* Faction comparison */
        .faction-compare {
            display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; align-items: start;
        }
        .faction-col { text-align: center; }
        .faction-col h3 { margin-bottom: 10px; font-size: 1rem; }
        .faction-vs { display: flex; align-items: center; justify-content: center; font-size: 1.2rem; font-weight: 700; color: var(--text-muted); padding-top: 30px; }
        
        /* Veto helper */
        .veto-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        .veto-section h4 { font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }
        .veto-map {
            display: flex; justify-content: space-between; align-items: center; padding: 6px 10px;
            border-radius: 4px; margin-bottom: 4px; font-size: 13px;
        }
        .veto-map.pick { background: rgba(63, 185, 80, 0.1); border-left: 3px solid var(--accent-green); }
        .veto-map.ban { background: rgba(248, 81, 73, 0.1); border-left: 3px solid var(--accent-red); }
        .veto-record { font-size: 11px; color: var(--text-secondary); }
        .veto-winrate { font-weight: 700; min-width: 40px; text-align: right; }
        
        /* Map deep dive */
        .map-expand-btn {
            background: none; border: none; color: var(--text-muted); cursor: pointer;
            font-size: 12px; padding: 0; margin-right: 8px; transition: color 0.15s;
        }
        .map-expand-btn:hover { color: var(--accent-orange); }
        .map-faction-detail { display: none; padding: 4px 0 4px 24px; font-size: 12px; color: var(--text-secondary); }
        .map-faction-detail.visible { display: block; }
        
        /* Monthly table */
        .trend-bar {
            display: inline-block; height: 6px; border-radius: 3px; vertical-align: middle; margin-left: 6px;
        }
        
        /* Score analysis */
        .score-category {
            display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid var(--border-color); gap: 12px;
        }
        .score-category:last-child { border-bottom: none; }
        .score-cat-label { min-width: 110px; font-weight: 500; font-size: 13px; }
        .score-cat-count { min-width: 60px; font-size: 12px; color: var(--text-secondary); }
        .score-cat-winrate { font-weight: 700; min-width: 50px; text-align: right; }
        
        /* Match history */
        .match-result-badge {
            display: inline-block; padding: 2px 8px; border-radius: 3px; font-size: 11px; font-weight: 700;
        }
        .match-result-badge.W { background: rgba(63, 185, 80, 0.2); color: var(--accent-green); }
        .match-result-badge.L { background: rgba(248, 81, 73, 0.2); color: var(--accent-red); }
        .match-result-badge.D { background: rgba(255,255,255,0.1); color: var(--text-secondary); }
        .enemy-strength {
            display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-left: 6px;
            vertical-align: middle; title: '';
        }
        .enemy-strength.easy { background: var(--accent-green); }
        .enemy-strength.medium { background: var(--accent-orange); }
        .enemy-strength.hard { background: var(--accent-red); }
        
        /* Role leaderboard chips */
        .role-chips-bar { display: flex; gap: 6px; flex-wrap: wrap; align-items: center; }
        .role-chip-btn {
            padding: 4px 12px; border-radius: 14px; font-size: 12px; font-weight: 500;
            border: 1px solid var(--border-color); background: transparent; color: var(--text-secondary);
            cursor: pointer; transition: all 0.15s; white-space: nowrap;
        }
        .role-chip-btn:hover { border-color: var(--accent-orange); color: var(--text-primary); }
        .role-chip-btn.active { background: var(--accent-orange); color: #000; border-color: var(--accent-orange); font-weight: 600; }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav-bar">
        <a href="../index.html" class="nav-logo">HLL Tool</a>
        <div class="nav-links">
            <a href="../index.html" class="nav-link">Home</a>
            <a href="lineup.html" class="nav-link">Lineups</a>
            <a href="roster.html" class="nav-link">Roster</a>
            <a href="stats.html" class="nav-link active">Stats</a>
            <a href="matches.html" class="nav-link">Matches</a>
            <a href="enemies.html" class="nav-link">Enemy Intel</a>
            <a href="admin.html" class="nav-link">Admin</a>
        </div>
        <div class="nav-spacer"></div>
        <div class="nav-status">
            <span class="status-dot"></span>
            <span>Connecting...</span>
        </div>
    </nav>

    <div class="app-container">
        <!-- Header -->
        <div class="page-header">
            <h1 class="page-title">Team Stats</h1>
            <span class="version-badge">v0.6.10</span>
        </div>

        <!-- Tabs -->
        <div style="display: flex; gap: 0; margin-bottom: 20px; border-bottom: 2px solid rgba(255,255,255,0.1);">
            <div class="stats-tab active" onclick="switchStatsTab('players')" id="tab-btn-players" style="padding: 10px 20px; cursor: pointer; color: var(--accent-orange); border-bottom: 2px solid var(--accent-orange); margin-bottom: -2px; font-weight: 600;">Player Stats</div>
            <div class="stats-tab" onclick="switchStatsTab('games')" id="tab-btn-games" style="padding: 10px 20px; cursor: pointer; color: var(--text-secondary); border-bottom: 2px solid transparent; margin-bottom: -2px;">Game Stats</div>
            <div class="stats-tab" onclick="switchStatsTab('compare')" id="tab-btn-compare" style="padding: 10px 20px; cursor: pointer; color: var(--text-secondary); border-bottom: 2px solid transparent; margin-bottom: -2px;">Team Compare</div>
        </div>

        <!-- PLAYER STATS TAB (existing content) -->
        <div id="tab-players">

        <!-- Overall Stats -->
        <div class="stat-row" id="overallStats">
            <div class="stat-box">
                <span class="stat-value" id="totalMatches">-</span>
                <span class="stat-label">Total Matches</span>
            </div>
            <div class="stat-box">
                <span class="stat-value" id="totalWins">-</span>
                <span class="stat-label">Wins</span>
            </div>
            <div class="stat-box">
                <span class="stat-value" id="totalLosses">-</span>
                <span class="stat-label">Losses</span>
            </div>
            <div class="stat-box">
                <span class="stat-value" id="overallWinRate">-</span>
                <span class="stat-label">Win Rate</span>
            </div>
            <div class="stat-box">
                <span class="stat-value" id="pointsFor">-</span>
                <span class="stat-label">Points For</span>
            </div>
            <div class="stat-box">
                <span class="stat-value" id="pointsAgainst">-</span>
                <span class="stat-label">Points Against</span>
            </div>
        </div>

        <div class="stats-grid">
            <!-- Map Stats - Allies -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">
                        <span class="faction-badge faction-allies">‚òÖ Allies</span>
                        Map Performance
                    </span>
                </div>
                <div class="card-body" id="mapStatsAllies">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>

            <!-- Map Stats - Axis -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">
                        <span class="faction-badge faction-axis">‚ú† Axis</span>
                        Map Performance
                    </span>
                </div>
                <div class="card-body" id="mapStatsAxis">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Enemy Team Stats -->
        <div class="card mt-lg">
            <div class="card-header">
                <span class="card-title">üéØ Enemy Team Records</span>
            </div>
            <div class="card-body" id="enemyStats">
                <div class="text-center text-muted">Loading...</div>
            </div>
        </div>

        <!-- Role Leaders -->
        <div class="mt-lg">
            <div class="section-title">üéñÔ∏è Role Leaders</div>
            <div class="awards-grid" id="roleLeaderCards">
                <div class="text-center text-muted" style="grid-column: 1/-1;">Loading...</div>
            </div>
        </div>

        <!-- Achievement Awards -->
        <div class="mt-lg">
            <div class="section-title">üèÖ Achievements</div>
            <div class="awards-grid" id="achievementCards">
                <div class="text-center text-muted" style="grid-column: 1/-1;">Loading...</div>
            </div>
        </div>

        <!-- Top Players -->
        <div class="stats-grid mt-lg">
            <!-- Top Killers -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">üèÜ Top Killers (Avg)</span>
                </div>
                <div class="card-body">
                    <table class="data-table" id="topKillersTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Player</th>
                                <th class="numeric">Avg Kills</th>
                                <th class="numeric">Matches</th>
                            </tr>
                        </thead>
                        <tbody id="topKillersBody">
                            <tr><td colspan="4" class="text-center text-muted">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Top K/D -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">‚öîÔ∏è Top K/D Ratio</span>
                </div>
                <div class="card-body">
                    <table class="data-table" id="topKDTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Player</th>
                                <th class="numeric">K/D</th>
                                <th class="numeric">Matches</th>
                            </tr>
                        </thead>
                        <tbody id="topKDBody">
                            <tr><td colspan="4" class="text-center text-muted">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Top MVPs -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">üåü Most MVPs</span>
                </div>
                <div class="card-body">
                    <table class="data-table" id="topMVPTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Player</th>
                                <th class="numeric">MVPs</th>
                                <th class="numeric">Matches</th>
                            </tr>
                        </thead>
                        <tbody id="topMVPBody">
                            <tr><td colspan="4" class="text-center text-muted">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Best Attendance -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">üìÖ Best Attendance</span>
                </div>
                <div class="card-body">
                    <table class="data-table" id="topAttendanceTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Player</th>
                                <th class="numeric">Attend%</th>
                                <th class="numeric">Matches</th>
                            </tr>
                        </thead>
                        <tbody id="topAttendanceBody">
                            <tr><td colspan="4" class="text-center text-muted">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Role Leaderboards -->
        <div class="card mt-lg">
            <div class="card-header" style="flex-direction: column; align-items: flex-start; gap: 10px;">
                <span class="card-title">üéØ Role Leaderboards (PPS)</span>
                <div class="role-chips-bar" id="roleChipsBar">
                    <button class="role-chip-btn" onclick="selectRoleChip(this, 'Infantry')">Infantry</button>
                    <button class="role-chip-btn" onclick="selectRoleChip(this, 'Squad Leader')">Squad Leader</button>
                    <button class="role-chip-btn" onclick="selectRoleChip(this, 'Defence')">Defence</button>
                    <button class="role-chip-btn" onclick="selectRoleChip(this, 'Defence SL')">Defence SL</button>
                    <button class="role-chip-btn" onclick="selectRoleChip(this, 'Spotter')">Spotter</button>
                    <button class="role-chip-btn" onclick="selectRoleChip(this, 'Sniper')">Sniper</button>
                    <button class="role-chip-btn" onclick="selectRoleChip(this, 'Tank Crew')">Tank Crew</button>
                    <button class="role-chip-btn" onclick="selectRoleChip(this, 'Commander')">Commander</button>
                    <button class="role-chip-btn" onclick="selectRoleChip(this, 'Artillery')">Artillery</button>
                </div>
            </div>
            <div class="card-body" id="roleLeaderboard">
                <div class="text-center text-muted">Select a role to see player rankings by PPS</div>
            </div>
        </div>

        </div><!-- end tab-players -->

        <!-- GAME STATS TAB -->
        <div id="tab-games" style="display: none;">

            <!-- Overall Summary -->
            <div class="stat-row" id="gameOverallStats">
                <div class="stat-box"><span class="stat-value" id="gTotalMatches">-</span><span class="stat-label">Total Matches</span></div>
                <div class="stat-box"><span class="stat-value" id="gWins">-</span><span class="stat-label">Wins</span></div>
                <div class="stat-box"><span class="stat-value" id="gLosses">-</span><span class="stat-label">Losses</span></div>
                <div class="stat-box"><span class="stat-value" id="gWinRate">-</span><span class="stat-label">Win Rate</span></div>
                <div class="stat-box"><span class="stat-value" id="gPtsFor">-</span><span class="stat-label">Points For</span></div>
                <div class="stat-box"><span class="stat-value" id="gPtsAgainst">-</span><span class="stat-label">Points Against</span></div>
            </div>

            <!-- Form & Streaks -->
            <div class="card mt-lg">
                <div class="card-header"><span class="card-title">üìä Form & Streaks</span></div>
                <div class="card-body" id="formStreaks">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>

            <!-- Faction Analysis -->
            <div class="card mt-lg">
                <div class="card-header"><span class="card-title">‚öîÔ∏è Faction Analysis</span></div>
                <div class="card-body" id="factionAnalysis">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>

            <!-- Map Veto Helper -->
            <div class="card mt-lg">
                <div class="card-header"><span class="card-title">üó∫Ô∏è Map Veto Helper</span><span style="font-size: 11px; color: var(--text-muted); margin-left: 8px;">min 2 games played</span></div>
                <div class="card-body" id="vetoHelper">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>

            <!-- Map Deep Dive -->
            <div class="card mt-lg">
                <div class="card-header"><span class="card-title">üó∫Ô∏è Map Deep-Dive</span></div>
                <div class="card-body" id="mapDeepDive">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>

            <!-- Performance Over Time -->
            <div class="card mt-lg">
                <div class="card-header"><span class="card-title">üìà Performance Over Time</span></div>
                <div class="card-body" id="perfOverTime">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>

            <!-- Score Analysis -->
            <div class="card mt-lg">
                <div class="card-header"><span class="card-title">üéØ Score Analysis</span></div>
                <div class="card-body" id="scoreAnalysis">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>

            <!-- Match History -->
            <div class="card mt-lg">
                <div class="card-header"><span class="card-title">üìã Match History</span></div>
                <div class="card-body" id="matchHistory">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>

        </div><!-- end tab-games -->

        <!-- TEAM COMPARE TAB -->
        <div id="tab-compare" style="display: none;">
            
            <!-- My Team Summary -->
            <div class="card">
                <div class="card-header"><span class="card-title">üìä My Team Summary</span></div>
                <div class="card-body" id="myTeamSummary">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>

            <!-- Division Rankings -->
            <div class="card mt-lg">
                <div class="card-header">
                    <span class="card-title">üèÜ Division Rankings</span>
                    <select id="divisionFilter" style="background: var(--bg-input, #1a1a2e); border: 1px solid rgba(255,255,255,0.15); border-radius: 4px; color: var(--text-primary); padding: 4px 8px; font-size: 0.85rem;">
                        <option value="">Select division...</option>
                    </select>
                </div>
                <div class="card-body" id="divisionRankings">
                    <div class="text-center text-muted">Select a division to see rankings</div>
                </div>
            </div>

            <!-- Head-to-Head -->
            <div class="card mt-lg">
                <div class="card-header">
                    <span class="card-title">‚öîÔ∏è Head-to-Head</span>
                    <select id="h2hTeamSelect" style="background: var(--bg-input, #1a1a2e); border: 1px solid rgba(255,255,255,0.15); border-radius: 4px; color: var(--text-primary); padding: 4px 8px; font-size: 0.85rem;">
                        <option value="">Select enemy team...</option>
                    </select>
                </div>
                <div class="card-body" id="headToHead">
                    <div class="text-center text-muted">Select an enemy team for head-to-head comparison</div>
                </div>
            </div>

            <!-- Player-level Comparison -->
            <div id="playerCompareSection" style="display: none;">
                <div class="card mt-lg">
                    <div class="card-header"><span class="card-title">üë• Player Comparison ‚Äî Top 10</span></div>
                    <div class="card-body" id="playerCompare">
                        <div class="text-center text-muted">Loading...</div>
                    </div>
                </div>
            </div>

        </div><!-- end tab-compare -->

    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay hidden" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading...</div>
    </div>

    <script src="../js/hll.js"></script>
    <script>
        async function init() {
            await HLL.initWithAuth(async () => {
                HLL.showLoading('Loading stats...');
                
                if (HLL.isOnline) {
                    await Promise.all([
                        loadOverallStats(),
                        loadMapStats(),
                        loadEnemyStats(),
                        loadPlayerLeaderboards(),
                        loadAwardCards()
                    ]);
                    initRoleLeaderboard();
                }
                
                HLL.hideLoading();
            });
        }
        
        async function loadOverallStats() {
            try {
                const matches = await HLL.loadMatches(1000);
                
                const wins = matches.filter(m => m.result === 'W').length;
                const losses = matches.filter(m => m.result === 'L').length;
                const pointsFor = matches.reduce((sum, m) => sum + (m.my_score || 0), 0);
                const pointsAgainst = matches.reduce((sum, m) => sum + (m.enemy_score || 0), 0);
                const winRate = matches.length > 0 ? Math.round((wins / matches.length) * 100) : 0;
                
                document.getElementById('totalMatches').textContent = matches.length;
                document.getElementById('totalWins').textContent = wins;
                document.getElementById('totalLosses').textContent = losses;
                document.getElementById('overallWinRate').textContent = winRate + '%';
                document.getElementById('pointsFor').textContent = pointsFor;
                document.getElementById('pointsAgainst').textContent = pointsAgainst;
            } catch (err) {
                console.error('Error loading overall stats:', err);
            }
        }
        
        async function loadMapStats() {
            try {
                const matches = await HLL.loadMatches(1000);
                const mapStats = {};
                
                matches.forEach(m => {
                    const key = `${m.map}-${m.my_faction}`;
                    if (!mapStats[key]) {
                        mapStats[key] = { map: m.map, faction: m.my_faction, matches: 0, wins: 0, losses: 0 };
                    }
                    mapStats[key].matches++;
                    if (m.result === 'W') mapStats[key].wins++;
                    if (m.result === 'L') mapStats[key].losses++;
                });
                
                const alliesStats = Object.values(mapStats).filter(s => s.faction === 'Allies').sort((a, b) => b.matches - a.matches);
                const axisStats = Object.values(mapStats).filter(s => s.faction === 'Axis').sort((a, b) => b.matches - a.matches);
                
                renderMapStats('mapStatsAllies', alliesStats);
                renderMapStats('mapStatsAxis', axisStats);
            } catch (err) {
                console.error('Error loading map stats:', err);
            }
        }
        
        function renderMapStats(containerId, stats) {
            const container = document.getElementById(containerId);
            
            if (stats.length === 0) {
                container.innerHTML = '<div class="text-center text-muted">No matches yet</div>';
                return;
            }
            
            container.innerHTML = stats.map(s => {
                const winRate = s.matches > 0 ? Math.round((s.wins / s.matches) * 100) : 0;
                const winRateClass = winRate >= 60 ? 'text-success' : (winRate < 40 ? 'text-danger' : '');
                
                return `
                    <div class="map-row">
                        <span class="map-name">${s.map}</span>
                        <div class="map-stats">
                            <span class="map-record">${s.wins}W - ${s.losses}L</span>
                            <span class="map-winrate ${winRateClass}">${winRate}%</span>
                        </div>
                    </div>
                    <div class="win-bar">
                        <div class="win-bar-fill" style="width: ${winRate}%"></div>
                    </div>
                `;
            }).join('');
        }
        
        async function loadEnemyStats() {
            try {
                const matches = await HLL.loadMatches(1000);
                const enemyStats = {};
                
                matches.forEach(m => {
                    const enemy = m.enemy_team;
                    if (!enemyStats[enemy]) {
                        enemyStats[enemy] = { enemy, matches: 0, wins: 0, losses: 0, pointsFor: 0, pointsAgainst: 0 };
                    }
                    enemyStats[enemy].matches++;
                    if (m.result === 'W') enemyStats[enemy].wins++;
                    if (m.result === 'L') enemyStats[enemy].losses++;
                    enemyStats[enemy].pointsFor += m.my_score || 0;
                    enemyStats[enemy].pointsAgainst += m.enemy_score || 0;
                });
                
                const sorted = Object.values(enemyStats).sort((a, b) => b.matches - a.matches);
                renderEnemyStats(sorted);
            } catch (err) {
                console.error('Error loading enemy stats:', err);
            }
        }
        
        function renderEnemyStats(stats) {
            const container = document.getElementById('enemyStats');
            
            if (stats.length === 0) {
                container.innerHTML = '<div class="text-center text-muted">No matches yet</div>';
                return;
            }
            
            container.innerHTML = stats.map(s => {
                const winRate = s.matches > 0 ? Math.round((s.wins / s.matches) * 100) : 0;
                const winRateClass = winRate >= 60 ? 'text-success' : (winRate < 40 ? 'text-danger' : '');
                const pointsDiff = s.pointsFor - s.pointsAgainst;
                const pointsDiffClass = pointsDiff > 0 ? 'positive' : (pointsDiff < 0 ? 'negative' : '');
                const pointsDiffText = pointsDiff > 0 ? `+${pointsDiff}` : pointsDiff;
                
                return `
                    <div class="enemy-row">
                        <span class="enemy-name">${s.enemy}</span>
                        <div class="enemy-stats">
                            <span style="min-width: 80px;">${s.matches} matches</span>
                            <span style="min-width: 80px;">${s.wins}W - ${s.losses}L</span>
                            <span class="map-winrate ${winRateClass}" style="min-width: 50px;">${winRate}%</span>
                            <span class="points-diff ${pointsDiffClass}">${pointsDiffText} pts</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        async function loadPlayerLeaderboards() {
            try {
                const players = await HLL.loadPlayers();
                const qualified = players.filter(p => p.total_matches >= 3);
                
                // Top Killers
                const topKillers = [...qualified].sort((a, b) => (b.avg_kills || 0) - (a.avg_kills || 0)).slice(0, 10);
                renderLeaderboard('topKillersBody', topKillers, 'avg_kills');
                
                // Top K/D
                const topKD = [...qualified]
                    .map(p => ({ ...p, kd: p.total_deaths > 0 ? (p.total_kills / p.total_deaths) : 0 }))
                    .sort((a, b) => b.kd - a.kd).slice(0, 10);
                renderLeaderboard('topKDBody', topKD, 'kd', 2);
                
                // Top MVPs
                const topMVP = [...players].sort((a, b) => (b.mvp_count || 0) - (a.mvp_count || 0)).filter(p => p.mvp_count > 0).slice(0, 10);
                renderLeaderboard('topMVPBody', topMVP, 'mvp_count');
                
                // Best Attendance
                const topAttendance = [...players]
                    .filter(p => (p.total_matches + (p.no_shows || 0)) >= 5)
                    .map(p => ({ ...p, attendance: p.total_matches / (p.total_matches + (p.no_shows || 0)) * 100 }))
                    .sort((a, b) => b.attendance - a.attendance).slice(0, 10);
                renderLeaderboard('topAttendanceBody', topAttendance, 'attendance', 0, '%');
            } catch (err) {
                console.error('Error loading leaderboards:', err);
            }
        }
        
        function renderLeaderboard(tableId, players, statKey, decimals = 1, suffix = '') {
            const tbody = document.getElementById(tableId);
            
            if (players.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">No data</td></tr>';
                return;
            }
            
            tbody.innerHTML = players.map((p, i) => `
                <tr>
                    <td class="center">${i + 1}</td>
                    <td>${HLL.formatPlayerName(p.name, p.team)}</td>
                    <td class="numeric">${(p[statKey] || 0).toFixed(decimals)}${suffix}</td>
                    <td class="numeric">${p.total_matches || 0}</td>
                </tr>
            `).join('');
        }
        
        // ============================================================================
        // AWARD CARDS
        // ============================================================================
        
        function renderAwardCard(icon, title, players, statFn, id) {
            if (!players || players.length === 0) {
                return `<div class="award-card"><div class="award-header"><span class="award-title">${title}</span><span class="award-icon">${icon}</span></div><div class="award-empty">Not enough data</div></div>`;
            }
            const winner = players[0];
            const runners = players.slice(1, 10);
            const runnersId = 'runners-' + id;
            return `<div class="award-card">
                <div class="award-header"><span class="award-title">${title}</span><span class="award-icon">${icon}</span></div>
                <div class="award-winner">${winner.name}</div>
                <div class="award-stat">${statFn(winner)}</div>
                ${runners.length > 0 ? `<button class="award-expand" onclick="toggleRunners('${runnersId}')">‚ñ∏ Top ${runners.length + 1}</button>
                <div class="award-runners" id="${runnersId}">
                    ${runners.map((p, i) => `<div class="runner-row"><span class="runner-rank">#${i + 2}</span><span class="runner-name">${p.name}</span><span class="runner-stat">${statFn(p)}</span></div>`).join('')}
                </div>` : ''}
            </div>`;
        }
        
        function toggleRunners(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.toggle('visible');
                const btn = el.previousElementSibling;
                if (btn) btn.textContent = el.classList.contains('visible') ? '‚ñæ Collapse' : '‚ñ∏ Top 10';
            }
        }
        
        async function loadAwardCards() {
            try {
                // Fetch all data we need
                const [detailsRes, lineupsRes, playersRes, matchesRes] = await Promise.all([
                    HLL.supabase.from('match_details').select('*').eq('team', 'Friendly'),
                    HLL.supabase.from('match_lineups').select('*'),
                    HLL.supabase.from('players').select('*'),
                    HLL.supabase.from('matches').select('match_id, date, result')
                ]);
                
                const details = detailsRes.data || [];
                const lineups = lineupsRes.data || [];
                const allPlayers = playersRes.data || [];
                const matches = matchesRes.data || [];
                
                if (details.length === 0 && lineups.length === 0) {
                    document.getElementById('roleLeaderCards').innerHTML = '<div class="text-center text-muted" style="grid-column:1/-1">Import match data to see role leaders</div>';
                    document.getElementById('achievementCards').innerHTML = '<div class="text-center text-muted" style="grid-column:1/-1">Import match data to see achievements</div>';
                    return;
                }
                
                // === BUILD PLAYER STAT MAPS ===
                
                // Per-player match stats from match_details
                const playerStats = {};
                details.forEach(d => {
                    const key = d.steam_id || d.player_name;
                    if (!playerStats[key]) playerStats[key] = { name: d.player_name, matches: [], steamId: d.steam_id };
                    playerStats[key].matches.push(d);
                });
                
                // Per-player role counts from match_lineups
                const playerRoles = {};
                lineups.forEach(l => {
                    const key = l.steam_id || l.player_name;
                    if (!playerRoles[key]) playerRoles[key] = { name: l.player_name, roles: {}, sections: {}, matchIds: new Set() };
                    const role = l.role || 'Unknown';
                    const section = l.section || '';
                    playerRoles[key].roles[role] = (playerRoles[key].roles[role] || 0) + 1;
                    if (section) playerRoles[key].sections[section] = (playerRoles[key].sections[section] || 0) + 1;
                    playerRoles[key].matchIds.add(l.match_id);
                });
                
                // Helper: get avg stat for players with a specific role
                function topByRole(roleName, minMatches = 1) {
                    const candidates = [];
                    Object.entries(playerRoles).forEach(([key, pr]) => {
                        if (!pr.roles[roleName]) return;
                        const ps = playerStats[key];
                        if (!ps || ps.matches.length < minMatches) return;
                        // Get only matches where they played this role
                        const roleMatchIds = new Set();
                        lineups.filter(l => (l.steam_id || l.player_name) === key && l.role === roleName).forEach(l => roleMatchIds.add(l.match_id));
                        const roleMatches = ps.matches.filter(m => roleMatchIds.has(m.match_id));
                        if (roleMatches.length === 0) return;
                        const avgKills = roleMatches.reduce((s, m) => s + (m.kills || 0), 0) / roleMatches.length;
                        const avgDeaths = roleMatches.reduce((s, m) => s + (m.deaths || 0), 0) / roleMatches.length;
                        const avgCE = roleMatches.reduce((s, m) => s + (m.combat_eff || 0), 0) / roleMatches.length;
                        const avgSupport = roleMatches.reduce((s, m) => s + (m.support_pts || 0), 0) / roleMatches.length;
                        const avgDef = roleMatches.reduce((s, m) => s + (m.defensive_pts || 0), 0) / roleMatches.length;
                        candidates.push({
                            name: pr.name, games: roleMatches.length,
                            avgKills: avgKills.toFixed(1), avgDeaths: avgDeaths.toFixed(1),
                            avgCE: avgCE.toFixed(0), avgSupport: avgSupport.toFixed(0), avgDef: avgDef.toFixed(0),
                            kd: avgDeaths > 0 ? (avgKills / avgDeaths).toFixed(2) : avgKills.toFixed(2)
                        });
                    });
                    return candidates.sort((a, b) => parseFloat(b.kd) - parseFloat(a.kd));
                }
                
                // Helper: top by section (Defence squads)
                function topBySection(sectionMatch, minMatches = 1) {
                    const candidates = [];
                    Object.entries(playerRoles).forEach(([key, pr]) => {
                        const sectionCount = Object.entries(pr.sections)
                            .filter(([s]) => s.toLowerCase().includes(sectionMatch.toLowerCase()))
                            .reduce((sum, [, c]) => sum + c, 0);
                        if (sectionCount === 0) return;
                        const ps = playerStats[key];
                        if (!ps || ps.matches.length < minMatches) return;
                        const avgKills = ps.matches.reduce((s, m) => s + (m.kills || 0), 0) / ps.matches.length;
                        const avgDeaths = ps.matches.reduce((s, m) => s + (m.deaths || 0), 0) / ps.matches.length;
                        candidates.push({
                            name: pr.name, games: sectionCount,
                            avgKills: avgKills.toFixed(1),
                            kd: avgDeaths > 0 ? (avgKills / avgDeaths).toFixed(2) : avgKills.toFixed(2)
                        });
                    });
                    return candidates.sort((a, b) => parseFloat(b.kd) - parseFloat(a.kd));
                }
                
                // === ROLE LEADERS ===
                const topCmd = topByRole('Commander');
                const topDefSL = topByRole('Defence');  // Defence SL entries
                const topDefInf = topBySection('defence');
                const topTC = topByRole('TC');
                const topTankCrew = [...(topByRole('Gunner')), ...(topByRole('Driver'))].sort((a, b) => parseFloat(b.kd) - parseFloat(a.kd));
                const topRecon = [...(topByRole('Spotter')), ...(topByRole('Sniper'))].sort((a, b) => parseFloat(b.kd) - parseFloat(a.kd));
                
                // Squad Backbone: most games as any SL role
                const slBackbone = Object.entries(playerRoles).map(([key, pr]) => {
                    const slGames = Object.entries(pr.roles).filter(([r]) => r.includes('SL') || r === 'Commander').reduce((s, [, c]) => s + c, 0);
                    return { name: pr.name, games: slGames };
                }).filter(p => p.games > 0).sort((a, b) => b.games - a.games);
                
                // Rising Star: best K/D with < 5 matches
                const risingStars = Object.values(playerStats)
                    .filter(ps => ps.matches.length >= 1 && ps.matches.length < 5)
                    .map(ps => {
                        const avgK = ps.matches.reduce((s, m) => s + (m.kills || 0), 0) / ps.matches.length;
                        const avgD = ps.matches.reduce((s, m) => s + (m.deaths || 0), 0) / ps.matches.length;
                        return { name: ps.name, games: ps.matches.length, avgKills: avgK.toFixed(1), kd: avgD > 0 ? (avgK / avgD).toFixed(2) : avgK.toFixed(2) };
                    }).sort((a, b) => parseFloat(b.kd) - parseFloat(a.kd));
                
                const roleHTML = [
                    renderAwardCard('üéñÔ∏è', 'Top Commander', topCmd, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.avgKills} avg kills ¬∑ ${p.games} games`, 'cmd'),
                    renderAwardCard('üì£', 'Top SL', topByRole('SL'), p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.avgKills} avg kills ¬∑ ${p.games} games`, 'sl'),
                    renderAwardCard('üî´', 'Top Infantry', topByRole('Infantry'), p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.avgKills} avg kills ¬∑ ${p.games} games`, 'infantry'),
                    renderAwardCard('üõ°Ô∏è', 'Top Defence SL', topDefSL, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.avgDef} def pts ¬∑ ${p.games} games`, 'defsl'),
                    renderAwardCard('üè∞', 'Top Defence Inf', topDefInf, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.games} games`, 'definf'),
                    renderAwardCard('üéØ', 'Top TC', topTC, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.avgKills} avg kills ¬∑ ${p.games} games`, 'tc'),
                    renderAwardCard('üîß', 'Top Tank Crew', topTankCrew, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.games} games`, 'tank'),
                    renderAwardCard('üî≠', 'Top Recon', topRecon, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.games} games`, 'recon'),
                    renderAwardCard('üì¢', 'Squad Backbone', slBackbone, p => `<span class="highlight">${p.games}</span> games as SL/CMD`, 'backbone'),
                    renderAwardCard('‚≠ê', 'Rising Star', risingStars, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.avgKills} avg kills ¬∑ ${p.games} games`, 'rising'),
                ].join('');
                
                document.getElementById('roleLeaderCards').innerHTML = roleHTML;
                
                // === ACHIEVEMENTS ===
                
                // Top Support (avg support points)
                const topSupport = Object.values(playerStats)
                    .filter(ps => ps.matches.length >= 1)
                    .map(ps => {
                        const avg = ps.matches.reduce((s, m) => s + (m.support_pts || 0), 0) / ps.matches.length;
                        return { name: ps.name, games: ps.matches.length, avgSupport: avg.toFixed(0) };
                    }).sort((a, b) => parseFloat(b.avgSupport) - parseFloat(a.avgSupport));
                
                // Most Improved: compare first half vs second half of matches by date
                const mostImproved = Object.values(playerStats)
                    .filter(ps => ps.matches.length >= 4)
                    .map(ps => {
                        const sorted = [...ps.matches].sort((a, b) => (a.match_id || '').localeCompare(b.match_id || ''));
                        const half = Math.floor(sorted.length / 2);
                        const earlyKD = sorted.slice(0, half);
                        const lateKD = sorted.slice(half);
                        const earlyAvg = earlyKD.reduce((s, m) => s + (m.kills || 0), 0) / earlyKD.length;
                        const lateAvg = lateKD.reduce((s, m) => s + (m.kills || 0), 0) / lateKD.length;
                        const improvement = lateAvg - earlyAvg;
                        return { name: ps.name, games: ps.matches.length, improvement: improvement.toFixed(1), earlyAvg: earlyAvg.toFixed(1), lateAvg: lateAvg.toFixed(1) };
                    }).filter(p => parseFloat(p.improvement) > 0).sort((a, b) => parseFloat(b.improvement) - parseFloat(a.improvement));
                
                // Iron Man: longest attendance streak (consecutive matches)
                const matchDates = matches.sort((a, b) => (a.date || '').localeCompare(b.date || ''));
                const matchOrder = matchDates.map(m => m.match_id);
                const ironMan = Object.values(playerStats)
                    .filter(ps => ps.matches.length >= 2)
                    .map(ps => {
                        const playerMatchIds = new Set(ps.matches.map(m => m.match_id));
                        let maxStreak = 0, streak = 0;
                        matchOrder.forEach(mid => {
                            if (playerMatchIds.has(mid)) { streak++; maxStreak = Math.max(maxStreak, streak); }
                            else { streak = 0; }
                        });
                        return { name: ps.name, games: ps.matches.length, streak: maxStreak };
                    }).sort((a, b) => b.streak - a.streak);
                
                // Most Versatile: most unique roles played
                const versatile = Object.entries(playerRoles)
                    .map(([key, pr]) => ({ name: pr.name, roles: Object.keys(pr.roles).length, roleList: Object.keys(pr.roles).join(', '), games: pr.matchIds.size }))
                    .sort((a, b) => b.roles - a.roles);
                
                // The Reliable: best attendance with 10+ matches
                const reliable = allPlayers
                    .filter(p => (p.total_matches || 0) >= 10 && p.total_matches + (p.no_shows || 0) > 0)
                    .map(p => {
                        const pct = Math.round(p.total_matches / (p.total_matches + (p.no_shows || 0)) * 100);
                        return { name: p.name, games: p.total_matches, pct };
                    }).sort((a, b) => b.pct - a.pct || b.games - a.games);
                
                // The Veteran: most matches
                const veteran = allPlayers
                    .filter(p => (p.total_matches || 0) > 0)
                    .map(p => ({ name: p.name, games: p.total_matches || 0 }))
                    .sort((a, b) => b.games - a.games);
                
                // Node King: most games as Engineer/Support in node sections
                const nodeKing = Object.entries(playerRoles)
                    .map(([key, pr]) => {
                        const nodeGames = Object.entries(pr.sections)
                            .filter(([s]) => s.toLowerCase().includes('node'))
                            .reduce((sum, [, c]) => sum + c, 0);
                        return { name: pr.name, games: nodeGames };
                    }).filter(p => p.games > 0).sort((a, b) => b.games - a.games);
                
                // The Anchor: most games on defence squads
                const anchor = Object.entries(playerRoles)
                    .map(([key, pr]) => {
                        const defGames = Object.entries(pr.sections)
                            .filter(([s]) => s.toLowerCase().includes('defen'))
                            .reduce((sum, [, c]) => sum + c, 0)
                            + (pr.roles['Defence'] || 0);
                        return { name: pr.name, games: defGames };
                    }).filter(p => p.games > 0).sort((a, b) => b.games - a.games);
                
                // Always There: same as Iron Man but current streak
                const alwaysThere = Object.values(playerStats)
                    .filter(ps => ps.matches.length >= 1)
                    .map(ps => {
                        const playerMatchIds = new Set(ps.matches.map(m => m.match_id));
                        let streak = 0;
                        for (let i = matchOrder.length - 1; i >= 0; i--) {
                            if (playerMatchIds.has(matchOrder[i])) streak++;
                            else break;
                        }
                        return { name: ps.name, games: ps.matches.length, streak };
                    }).filter(p => p.streak > 0).sort((a, b) => b.streak - a.streak);
                
                // Team Player: highest avg support as non-SL
                const teamPlayer = Object.entries(playerRoles).map(([key, pr]) => {
                    const nonSLMatchIds = new Set();
                    lineups.filter(l => (l.steam_id || l.player_name) === key && !l.role?.includes('SL') && l.role !== 'Commander')
                        .forEach(l => nonSLMatchIds.add(l.match_id));
                    if (nonSLMatchIds.size === 0) return null;
                    const ps = playerStats[key];
                    if (!ps) return null;
                    const relevantMatches = ps.matches.filter(m => nonSLMatchIds.has(m.match_id));
                    if (relevantMatches.length === 0) return null;
                    const avgSup = relevantMatches.reduce((s, m) => s + (m.support_pts || 0), 0) / relevantMatches.length;
                    return { name: pr.name, games: relevantMatches.length, avgSupport: avgSup.toFixed(0) };
                }).filter(Boolean).sort((a, b) => parseFloat(b.avgSupport) - parseFloat(a.avgSupport));
                
                const achieveHTML = [
                    renderAwardCard('üí™', 'Top Support', topSupport, p => `<span class="highlight">${p.avgSupport}</span> avg support ¬∑ ${p.games} games`, 'support'),
                    renderAwardCard('üìà', 'Most Improved', mostImproved, p => `<span class="highlight">+${p.improvement}</span> avg kills ¬∑ ${p.earlyAvg} ‚Üí ${p.lateAvg}`, 'improved'),
                    renderAwardCard('üî•', 'Iron Man', ironMan, p => `<span class="highlight">${p.streak}</span> match streak ¬∑ ${p.games} total`, 'ironman'),
                    renderAwardCard('üé≠', 'Most Versatile', versatile, p => `<span class="highlight">${p.roles}</span> roles ¬∑ ${p.games} games`, 'versatile'),
                    renderAwardCard('‚úÖ', 'The Reliable', reliable, p => `<span class="highlight">${p.pct}%</span> attendance ¬∑ ${p.games} matches`, 'reliable'),
                    renderAwardCard('üëë', 'The Veteran', veteran, p => `<span class="highlight">${p.games}</span> matches played`, 'veteran'),
                    renderAwardCard('‚ö°', 'Node King', nodeKing, p => `<span class="highlight">${p.games}</span> node assignments`, 'nodeking'),
                    renderAwardCard('‚öì', 'The Anchor', anchor, p => `<span class="highlight">${p.games}</span> defence assignments`, 'anchor'),
                    renderAwardCard('üèÖ', 'Always There', alwaysThere, p => `<span class="highlight">${p.streak}</span> current streak ¬∑ ${p.games} total`, 'always'),
                    renderAwardCard('ü§ù', 'Team Player', teamPlayer, p => `<span class="highlight">${p.avgSupport}</span> avg support (non-SL) ¬∑ ${p.games} games`, 'teamplayer'),
                ].join('');
                
                document.getElementById('achievementCards').innerHTML = achieveHTML;
                
            } catch (err) {
                console.error('Error loading award cards:', err);
                document.getElementById('roleLeaderCards').innerHTML = '<div class="text-center text-muted" style="grid-column:1/-1">Error loading role leaders</div>';
                document.getElementById('achievementCards').innerHTML = '<div class="text-center text-muted" style="grid-column:1/-1">Error loading achievements</div>';
            }
        }
        
        // ============================================================================
        // ROLE LEADERBOARDS
        // ============================================================================
        function initRoleLeaderboard() {
            // Chips are wired via onclick in HTML, no init needed
        }

        function selectRoleChip(btn, roleGroup) {
            // Toggle active state
            document.querySelectorAll('#roleChipsBar .role-chip-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            loadRoleLeaderboard(roleGroup);
        }

        async function loadRoleLeaderboard(roleGroup) {
            const section = document.getElementById('roleLeaderboard');
            if (!roleGroup) {
                section.innerHTML = '<div class="text-center text-muted">Select a role to see player rankings by PPS</div>';
                return;
            }
            
            section.innerHTML = '<div class="text-center text-muted">Loading...</div>';

            const { data, error } = await HLL.supabase
                .from('role_leaderboard')
                .select('*')
                .eq('role_group', roleGroup)
                .order('avg_pps', { ascending: false });

            if (error) {
                section.innerHTML = `<div class="text-center text-muted">Error: ${error.message}</div>`;
                return;
            }

            if (!data || data.length === 0) {
                section.innerHTML = '<div class="text-center text-muted">No data for this role yet. Import matches with lineup data to populate.</div>';
                return;
            }

            // Choose which columns to emphasize based on role
            const isDefence = roleGroup === 'Defence' || roleGroup === 'Defence SL';
            const isSupport = roleGroup === 'Spotter' || roleGroup === 'Commander';
            const isTank = roleGroup === 'Tank Crew';

            section.innerHTML = `
                <table class="data-table" style="font-size: 0.85rem;">
                    <thead><tr>
                        <th>#</th>
                        <th>Player</th>
                        <th>Matches</th>
                        <th>Avg PPS</th>
                        <th>Best PPS</th>
                        <th>Avg K</th>
                        <th>Avg D</th>
                        <th>Avg K/D</th>
                        <th>Avg CE</th>
                        ${isDefence ? '<th style="color: #4ade80">Avg Def</th>' : '<th>Avg Def</th>'}
                        <th>Avg Off</th>
                        ${isSupport ? '<th style="color: #4ade80">Avg Sup</th>' : '<th>Avg Sup</th>'}
                    </tr></thead>
                    <tbody>
                        ${data.map((p, i) => `<tr>
                            <td>${i + 1}</td>
                            <td>${p.player_name}</td>
                            <td>${p.matches_in_role}</td>
                            <td><strong>${p.avg_pps}</strong></td>
                            <td>${p.best_pps}</td>
                            <td>${p.avg_kills}</td>
                            <td>${p.avg_deaths}</td>
                            <td>${p.avg_kd}</td>
                            <td>${p.avg_ce}</td>
                            <td>${p.avg_def}</td>
                            <td>${p.avg_off}</td>
                            <td>${p.avg_sup}</td>
                        </tr>`).join('')}
                    </tbody>
                </table>
                <p style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 8px;">
                    PPS = Performance Score based on combat, offense, defense, and support metrics weighted by K/D and KPM factors.
                    ${isDefence ? ' Defence players are expected to have higher defensive_pts.' : ''}
                    ${isSupport ? ' Support-oriented roles weight support_pts more heavily.' : ''}
                </p>`;
        }

        // ============================================================================
        // TAB SWITCHING
        // ============================================================================
        function switchStatsTab(tab) {
            const tabs = ['players', 'games', 'compare'];
            tabs.forEach(t => {
                document.getElementById('tab-' + t).style.display = t === tab ? 'block' : 'none';
                document.getElementById('tab-btn-' + t).style.color = t === tab ? 'var(--accent-orange)' : 'var(--text-secondary)';
                document.getElementById('tab-btn-' + t).style.borderBottomColor = t === tab ? 'var(--accent-orange)' : 'transparent';
            });

            if (tab === 'games' && !window._gamesLoaded) {
                window._gamesLoaded = true;
                loadGameStatsTab();
            }

            if (tab === 'compare' && !window._compareLoaded) {
                window._compareLoaded = true;
                loadCompareTab();
            }
        }

        // ============================================================================
        // COMPARE TAB
        // ============================================================================
        async function loadCompareTab() {
            await Promise.all([
                loadMyTeamSummary(),
                loadDivisionDropdown(),
                loadH2HDropdown()
            ]);
        }

        // --- MY TEAM SUMMARY ---
        async function loadMyTeamSummary() {
            const section = document.getElementById('myTeamSummary');
            const myTeam = HLL.currentTeam || 'Circle';

            // Get my team's match stats
            const { data: matches } = await HLL.supabase
                .from('matches')
                .select('*')
                .eq('my_team', myTeam);

            // Get my team's player stats from match_details
            const { data: details } = await HLL.supabase
                .from('match_details')
                .select('kills, deaths, combat_eff')
                .eq('team', 'Friendly');

            if (!matches || matches.length === 0) {
                section.innerHTML = '<div class="text-center text-muted">No matches found</div>';
                return;
            }

            const totalMatches = matches.length;
            const wins = matches.filter(m => m.result === 'W').length;
            const losses = matches.filter(m => m.result === 'L').length;
            const draws = matches.filter(m => m.result === 'D').length;
            const winRate = totalMatches > 0 ? Math.round(wins / totalMatches * 100) : 0;
            const ptsFor = matches.reduce((s, m) => s + (m.my_score || 0), 0);
            const ptsAgainst = matches.reduce((s, m) => s + (m.enemy_score || 0), 0);

            const totalKills = (details || []).reduce((s, d) => s + (d.kills || 0), 0);
            const totalDeaths = (details || []).reduce((s, d) => s + (d.deaths || 0), 0);
            const avgKillsPerMatch = totalMatches > 0 ? (totalKills / totalMatches).toFixed(0) : '-';
            const avgDeathsPerMatch = totalMatches > 0 ? (totalDeaths / totalMatches).toFixed(0) : '-';
            const teamKD = totalDeaths > 0 ? (totalKills / totalDeaths).toFixed(2) : '-';

            // Get my divisions
            const { data: myDivs } = await HLL.supabase
                .from('my_team_divisions')
                .select('division_id')
                .eq('team_name', myTeam);
            let divNames = [];
            if (myDivs && myDivs.length > 0) {
                const { data: divData } = await HLL.supabase
                    .from('divisions')
                    .select('name')
                    .in('id', myDivs.map(d => d.division_id));
                divNames = (divData || []).map(d => d.name);
            }

            section.innerHTML = `
                <div style="margin-bottom: 12px;">
                    <span style="font-size: 1.2rem; font-weight: 700;">${myTeam}</span>
                    ${divNames.length > 0 ? '<span style="margin-left: 8px;">' + divNames.map(n => `<span style="padding: 2px 8px; border-radius: 3px; font-size: 0.75rem; background: rgba(255,152,0,0.15); color: #ff9800;">${n}</span>`).join(' ') + '</span>' : ''}
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px;">
                    <div class="stat-box"><span class="stat-value">${totalMatches}</span><span class="stat-label">Matches</span></div>
                    <div class="stat-box"><span class="stat-value" style="color: var(--accent-green)">${wins}</span><span class="stat-label">Wins</span></div>
                    <div class="stat-box"><span class="stat-value" style="color: var(--accent-red)">${losses}</span><span class="stat-label">Losses</span></div>
                    <div class="stat-box"><span class="stat-value">${winRate}%</span><span class="stat-label">Win Rate</span></div>
                    <div class="stat-box"><span class="stat-value">${ptsFor}-${ptsAgainst}</span><span class="stat-label">Score F/A</span></div>
                    <div class="stat-box"><span class="stat-value" style="color: ${parseFloat(teamKD) >= 1 ? 'var(--accent-green)' : 'var(--accent-red)'}">${teamKD}</span><span class="stat-label">Team K/D</span></div>
                    <div class="stat-box"><span class="stat-value">${avgKillsPerMatch}</span><span class="stat-label">Avg Kills/Match</span></div>
                    <div class="stat-box"><span class="stat-value">${avgDeathsPerMatch}</span><span class="stat-label">Avg Deaths/Match</span></div>
                </div>`;
        }

        // --- DIVISION RANKINGS ---
        async function loadDivisionDropdown() {
            const { data: divs } = await HLL.supabase
                .from('divisions')
                .select('*')
                .order('sort_order', { ascending: true });
            
            const select = document.getElementById('divisionFilter');
            (divs || []).forEach(d => {
                const opt = document.createElement('option');
                opt.value = d.id;
                opt.textContent = d.name;
                select.appendChild(opt);
            });
            select.addEventListener('change', () => loadDivisionRankings(select.value));
        }

        async function loadDivisionRankings(divisionId) {
            const section = document.getElementById('divisionRankings');
            if (!divisionId) {
                section.innerHTML = '<div class="text-center text-muted">Select a division to see rankings</div>';
                return;
            }

            section.innerHTML = '<div class="text-center text-muted">Loading...</div>';

            // Get division name
            const { data: divData } = await HLL.supabase
                .from('divisions')
                .select('name')
                .eq('id', divisionId)
                .single();
            const divName = divData?.name || '';

            // Get all enemy teams in this division
            const { data: teamLinks } = await HLL.supabase
                .from('enemy_team_divisions')
                .select('team_tag')
                .eq('division_id', divisionId);
            const enemyTags = (teamLinks || []).map(t => t.team_tag);

            // Check if my team is in this division
            const myTeam = HLL.currentTeam || 'Circle';
            const { data: myInDiv } = await HLL.supabase
                .from('my_team_divisions')
                .select('id')
                .eq('team_name', myTeam)
                .eq('division_id', divisionId);
            const myTeamInDiv = myInDiv && myInDiv.length > 0;

            // Get ALL matches of this division type (filtered by match_type)
            const { data: divMatches } = await HLL.supabase
                .from('matches')
                .select('*')
                .eq('match_type', divName);

            // Build rankings array
            const rankings = [];

            // Calculate stats per enemy team from division matches only
            for (const tag of enemyTags) {
                const teamMatches = (divMatches || []).filter(m => m.enemy_team === tag);
                if (teamMatches.length === 0) {
                    rankings.push({ tag, name: tag, matches: 0, wins: 0, losses: 0, winRate: 0, ptsFor: 0, ptsAgainst: 0, isMyTeam: false });
                    continue;
                }
                // From our perspective: our W = their L, our L = their W
                const theirWins = teamMatches.filter(m => m.result === 'L').length;
                const theirLosses = teamMatches.filter(m => m.result === 'W').length;
                rankings.push({
                    tag,
                    name: tag,
                    matches: teamMatches.length,
                    wins: theirWins,
                    losses: theirLosses,
                    winRate: teamMatches.length > 0 ? Math.round(theirWins / teamMatches.length * 100) : 0,
                    ptsFor: teamMatches.reduce((s, m) => s + (m.enemy_score || 0), 0),
                    ptsAgainst: teamMatches.reduce((s, m) => s + (m.my_score || 0), 0),
                    isMyTeam: false
                });
            }

            // Get my team stats (only matches of this division type)
            const myMatches = (divMatches || []).filter(m => m.my_team === myTeam);

            // Add my team if in this division
            if (myTeamInDiv && myMatches.length > 0) {
                const mw = myMatches.filter(m => m.result === 'W').length;
                const ml = myMatches.filter(m => m.result === 'L').length;
                rankings.push({
                    tag: myTeam,
                    name: myTeam,
                    matches: myMatches.length,
                    wins: mw,
                    losses: ml,
                    winRate: myMatches.length > 0 ? Math.round(mw / myMatches.length * 100) : 0,
                    ptsFor: myMatches.reduce((s, m) => s + (m.my_score || 0), 0),
                    ptsAgainst: myMatches.reduce((s, m) => s + (m.enemy_score || 0), 0),
                    isMyTeam: true
                });
            }

            // Sort by win rate desc, then wins desc
            rankings.sort((a, b) => b.winRate - a.winRate || b.wins - a.wins);

            if (rankings.length === 0) {
                section.innerHTML = '<div class="text-center text-muted">No teams found in this division</div>';
                return;
            }

            section.innerHTML = `
                <table class="data-table">
                    <thead><tr>
                        <th>#</th><th>Team</th><th>Matches</th><th>W</th><th>L</th><th>Win Rate</th><th>Pts F/A</th>
                    </tr></thead>
                    <tbody>
                        ${rankings.map((t, i) => `
                            <tr style="${t.isMyTeam ? 'background: rgba(255,152,0,0.1); font-weight: 600;' : ''}">
                                <td>${i + 1}</td>
                                <td>${t.isMyTeam ? '‚≠ê ' : ''}[${t.tag}] ${t.name !== t.tag ? t.name : ''}</td>
                                <td>${t.matches}</td>
                                <td style="color: var(--accent-green)">${t.wins}</td>
                                <td style="color: var(--accent-red)">${t.losses}</td>
                                <td><strong>${t.winRate}%</strong></td>
                                <td>${t.ptsFor}-${t.ptsAgainst}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>`;
        }

        // --- HEAD TO HEAD ---
        async function loadH2HDropdown() {
            const { data: teams } = await HLL.supabase
                .from('enemy_teams')
                .select('tag, name')
                .order('tag');
            
            const select = document.getElementById('h2hTeamSelect');
            (teams || []).forEach(t => {
                const opt = document.createElement('option');
                opt.value = t.tag;
                opt.textContent = `[${t.tag}] ${t.name || ''}`;
                select.appendChild(opt);
            });
            select.addEventListener('change', () => loadHeadToHead(select.value));
        }

        async function loadHeadToHead(enemyTag) {
            const section = document.getElementById('headToHead');
            const playerSection = document.getElementById('playerCompareSection');
            if (!enemyTag) {
                section.innerHTML = '<div class="text-center text-muted">Select an enemy team for head-to-head comparison</div>';
                playerSection.style.display = 'none';
                return;
            }

            section.innerHTML = '<div class="text-center text-muted">Loading...</div>';
            const myTeam = HLL.currentTeam || 'Circle';

            // Get matches against this team
            const { data: matches } = await HLL.supabase
                .from('matches')
                .select('*')
                .eq('enemy_team', enemyTag);

            if (!matches || matches.length === 0) {
                section.innerHTML = '<div class="text-center text-muted">No matches found against this team</div>';
                playerSection.style.display = 'none';
                return;
            }

            const matchIds = matches.map(m => m.match_id);

            // Get all match_details for these matches
            const { data: details } = await HLL.supabase
                .from('match_details')
                .select('*')
                .in('match_id', matchIds);

            const friendly = (details || []).filter(d => d.team === 'Friendly');
            const enemy = (details || []).filter(d => d.team === 'Enemy');

            const myKills = friendly.reduce((s, d) => s + (d.kills || 0), 0);
            const myDeaths = friendly.reduce((s, d) => s + (d.deaths || 0), 0);
            const theirKills = enemy.reduce((s, d) => s + (d.kills || 0), 0);
            const theirDeaths = enemy.reduce((s, d) => s + (d.deaths || 0), 0);

            const wins = matches.filter(m => m.result === 'W').length;
            const losses = matches.filter(m => m.result === 'L').length;
            const myKD = myDeaths > 0 ? (myKills / myDeaths).toFixed(2) : '-';
            const theirKD = theirDeaths > 0 ? (theirKills / theirDeaths).toFixed(2) : '-';
            const myAvgKills = matches.length > 0 ? (myKills / matches.length).toFixed(0) : '-';
            const theirAvgKills = matches.length > 0 ? (theirKills / matches.length).toFixed(0) : '-';

            const betterKD = parseFloat(myKD) > parseFloat(theirKD);

            section.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; align-items: start;">
                    <!-- My Team -->
                    <div style="text-align: center;">
                        <div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 12px; color: var(--accent-orange);">${myTeam}</div>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <div class="stat-box"><span class="stat-value" style="color: var(--accent-green)">${wins}</span><span class="stat-label">Wins</span></div>
                            <div class="stat-box"><span class="stat-value">${myKills}</span><span class="stat-label">Total Kills</span></div>
                            <div class="stat-box"><span class="stat-value">${myDeaths}</span><span class="stat-label">Total Deaths</span></div>
                            <div class="stat-box"><span class="stat-value" style="color: ${betterKD ? 'var(--accent-green)' : 'var(--accent-red)'}">${myKD}</span><span class="stat-label">K/D</span></div>
                            <div class="stat-box"><span class="stat-value">${myAvgKills}</span><span class="stat-label">Avg Kills/Match</span></div>
                        </div>
                    </div>
                    <!-- VS -->
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding-top: 40px;">
                        <div style="font-size: 1.5rem; font-weight: 700; color: var(--text-secondary);">VS</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px;">${matches.length} matches</div>
                    </div>
                    <!-- Enemy Team -->
                    <div style="text-align: center;">
                        <div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 12px; color: var(--text-primary);">[${enemyTag}]</div>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <div class="stat-box"><span class="stat-value" style="color: var(--accent-green)">${losses}</span><span class="stat-label">Wins</span></div>
                            <div class="stat-box"><span class="stat-value">${theirKills}</span><span class="stat-label">Total Kills</span></div>
                            <div class="stat-box"><span class="stat-value">${theirDeaths}</span><span class="stat-label">Total Deaths</span></div>
                            <div class="stat-box"><span class="stat-value" style="color: ${!betterKD ? 'var(--accent-green)' : 'var(--accent-red)'}">${theirKD}</span><span class="stat-label">K/D</span></div>
                            <div class="stat-box"><span class="stat-value">${theirAvgKills}</span><span class="stat-label">Avg Kills/Match</span></div>
                        </div>
                    </div>
                </div>`;

            // Load player comparison
            await loadPlayerComparison(matchIds, enemyTag);
        }

        // --- PLAYER COMPARISON ---
        async function loadPlayerComparison(matchIds, enemyTag) {
            const section = document.getElementById('playerCompareSection');
            const body = document.getElementById('playerCompare');
            section.style.display = 'block';
            body.innerHTML = '<div class="text-center text-muted">Loading...</div>';

            // Get friendly player stats for these matches
            const { data: friendlyDetails } = await HLL.supabase
                .from('match_details')
                .select('steam_id, player_name, kills, deaths')
                .in('match_id', matchIds)
                .eq('team', 'Friendly');

            // Get enemy player stats
            const { data: enemyDetails } = await HLL.supabase
                .from('match_details')
                .select('steam_id, player_name, kills, deaths')
                .in('match_id', matchIds)
                .eq('team', 'Enemy');

            // Aggregate by player
            function aggregatePlayers(details) {
                const map = {};
                (details || []).forEach(d => {
                    const key = d.steam_id || d.player_name;
                    if (!map[key]) map[key] = { name: d.player_name, kills: 0, deaths: 0, matches: 0 };
                    map[key].kills += d.kills || 0;
                    map[key].deaths += d.deaths || 0;
                    map[key].matches++;
                });
                return Object.values(map)
                    .map(p => ({ ...p, avgKills: (p.kills / p.matches).toFixed(1), kd: p.deaths > 0 ? (p.kills / p.deaths).toFixed(2) : '-' }))
                    .sort((a, b) => parseFloat(b.avgKills) - parseFloat(a.avgKills))
                    .slice(0, 10);
            }

            const myTop = aggregatePlayers(friendlyDetails);
            const theirTop = aggregatePlayers(enemyDetails);
            const maxRows = Math.max(myTop.length, theirTop.length);

            body.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                    <div>
                        <h4 style="text-align: center; margin-bottom: 8px; color: var(--accent-orange); font-size: 0.9rem;">Our Top Players</h4>
                        <table class="data-table" style="font-size: 0.85rem;">
                            <thead><tr><th>#</th><th>Name</th><th>Avg K</th><th>K/D</th></tr></thead>
                            <tbody>
                                ${myTop.map((p, i) => `<tr><td>${i+1}</td><td>${p.name}</td><td>${p.avgKills}</td><td>${p.kd}</td></tr>`).join('')}
                            </tbody>
                        </table>
                    </div>
                    <div>
                        <h4 style="text-align: center; margin-bottom: 8px; font-size: 0.9rem;">Their Top Players</h4>
                        <table class="data-table" style="font-size: 0.85rem;">
                            <thead><tr><th>#</th><th>Name</th><th>Avg K</th><th>K/D</th></tr></thead>
                            <tbody>
                                ${theirTop.map((p, i) => `<tr><td>${i+1}</td><td>${p.name}</td><td>${p.avgKills}</td><td>${p.kd}</td></tr>`).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>`;
        }

        // ============================================================================
        // GAME STATS TAB
        // ============================================================================
        async function loadGameStatsTab() {
            const matches = await HLL.loadMatches(1000);
            if (!matches || matches.length === 0) {
                ['formStreaks','factionAnalysis','vetoHelper','mapDeepDive','perfOverTime','scoreAnalysis','matchHistory'].forEach(id => {
                    document.getElementById(id).innerHTML = '<div class="text-center text-muted">No matches found</div>';
                });
                return;
            }

            // Sort by date ascending
            const sorted = [...matches].sort((a, b) => (a.date || '').localeCompare(b.date || ''));

            // Get match_details for team K/D calculations
            const { data: allDetails } = await HLL.supabase
                .from('match_details')
                .select('match_id, kills, deaths, team');

            // Build per-match K/D lookup
            const matchKD = {};
            (allDetails || []).forEach(d => {
                if (!matchKD[d.match_id]) matchKD[d.match_id] = { fKills: 0, fDeaths: 0 };
                if (d.team === 'Friendly') {
                    matchKD[d.match_id].fKills += d.kills || 0;
                    matchKD[d.match_id].fDeaths += d.deaths || 0;
                }
            });

            // Overall summary
            const wins = sorted.filter(m => m.result === 'W').length;
            const losses = sorted.filter(m => m.result === 'L').length;
            const ptsFor = sorted.reduce((s, m) => s + (m.my_score || 0), 0);
            const ptsAgainst = sorted.reduce((s, m) => s + (m.enemy_score || 0), 0);
            const winRate = sorted.length > 0 ? Math.round(wins / sorted.length * 100) : 0;
            document.getElementById('gTotalMatches').textContent = sorted.length;
            document.getElementById('gWins').textContent = wins;
            document.getElementById('gLosses').textContent = losses;
            document.getElementById('gWinRate').textContent = winRate + '%';
            document.getElementById('gPtsFor').textContent = ptsFor;
            document.getElementById('gPtsAgainst').textContent = ptsAgainst;

            // Enemy record lookup for strength indicator
            const enemyRecord = {};
            sorted.forEach(m => {
                const e = m.enemy_team;
                if (!enemyRecord[e]) enemyRecord[e] = { wins: 0, losses: 0, total: 0 };
                enemyRecord[e].total++;
                if (m.result === 'W') enemyRecord[e].wins++;
                if (m.result === 'L') enemyRecord[e].losses++;
            });

            renderFormStreaks(sorted);
            renderFactionAnalysis(sorted, matchKD);
            renderVetoHelper(sorted);
            renderMapDeepDive(sorted, matchKD);
            renderPerfOverTime(sorted, matchKD);
            renderScoreAnalysis(sorted);
            renderMatchHistory(sorted, enemyRecord);
        }

        function renderFormStreaks(matches) {
            const section = document.getElementById('formStreaks');
            const last10 = matches.slice(-10);

            // Streak calculations
            let currentStreak = 0, currentType = '';
            let longestWin = 0, longestLoss = 0, tempWin = 0, tempLoss = 0;
            matches.forEach(m => {
                if (m.result === 'W') { tempWin++; tempLoss = 0; longestWin = Math.max(longestWin, tempWin); }
                else if (m.result === 'L') { tempLoss++; tempWin = 0; longestLoss = Math.max(longestLoss, tempLoss); }
                else { tempWin = 0; tempLoss = 0; }
            });
            // Current streak from end
            for (let i = matches.length - 1; i >= 0; i--) {
                if (currentStreak === 0) { currentType = matches[i].result; currentStreak = 1; }
                else if (matches[i].result === currentType) { currentStreak++; }
                else break;
            }

            const streakColor = currentType === 'W' ? 'var(--accent-green)' : currentType === 'L' ? 'var(--accent-red)' : 'var(--text-secondary)';

            section.innerHTML = `
                <div style="margin-bottom: 14px;">
                    <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 6px;">Last ${last10.length} Matches</div>
                    <div class="form-dots">
                        ${last10.map(m => `<div class="form-dot ${m.result}" title="${m.date || ''}: ${m.result} vs ${m.enemy_team || '?'} (${m.my_score || 0}-${m.enemy_score || 0})">${m.result}</div>`).join('')}
                    </div>
                </div>
                <div class="streak-grid">
                    <div class="streak-card">
                        <div class="streak-value" style="color: ${streakColor}">${currentStreak}${currentType}</div>
                        <div class="streak-label">Current Streak</div>
                    </div>
                    <div class="streak-card">
                        <div class="streak-value" style="color: var(--accent-green)">${longestWin}</div>
                        <div class="streak-label">Longest Win Streak</div>
                    </div>
                    <div class="streak-card">
                        <div class="streak-value" style="color: var(--accent-red)">${longestLoss}</div>
                        <div class="streak-label">Longest Loss Streak</div>
                    </div>
                    <div class="streak-card">
                        <div class="streak-value">${last10.filter(m => m.result === 'W').length}/${last10.length}</div>
                        <div class="streak-label">Last ${last10.length} Win Rate</div>
                    </div>
                </div>`;
        }

        function renderFactionAnalysis(matches, matchKD) {
            const section = document.getElementById('factionAnalysis');
            const factions = {};
            matches.forEach(m => {
                const f = m.my_faction || 'Unknown';
                if (!factions[f]) factions[f] = { matches: 0, wins: 0, losses: 0, ptsFor: 0, ptsAgainst: 0, kills: 0, deaths: 0 };
                factions[f].matches++;
                if (m.result === 'W') factions[f].wins++;
                if (m.result === 'L') factions[f].losses++;
                factions[f].ptsFor += m.my_score || 0;
                factions[f].ptsAgainst += m.enemy_score || 0;
                const kd = matchKD[m.match_id];
                if (kd) { factions[f].kills += kd.fKills; factions[f].deaths += kd.fDeaths; }
            });

            const allies = factions['Allies'] || { matches: 0, wins: 0, losses: 0, ptsFor: 0, ptsAgainst: 0, kills: 0, deaths: 0 };
            const axis = factions['Axis'] || { matches: 0, wins: 0, losses: 0, ptsFor: 0, ptsAgainst: 0, kills: 0, deaths: 0 };

            function factionCol(f, label, colorClass) {
                const wr = f.matches > 0 ? Math.round(f.wins / f.matches * 100) : 0;
                const avgPtsF = f.matches > 0 ? (f.ptsFor / f.matches).toFixed(1) : '-';
                const avgPtsA = f.matches > 0 ? (f.ptsAgainst / f.matches).toFixed(1) : '-';
                const kd = f.deaths > 0 ? (f.kills / f.deaths).toFixed(2) : '-';
                return `
                    <div class="faction-col">
                        <h3><span class="faction-badge ${colorClass}">${label}</span></h3>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <div class="stat-box"><span class="stat-value">${f.matches}</span><span class="stat-label">Matches</span></div>
                            <div class="stat-box"><span class="stat-value">${f.wins}W - ${f.losses}L</span><span class="stat-label">Record</span></div>
                            <div class="stat-box"><span class="stat-value" style="color: ${wr >= 50 ? 'var(--accent-green)' : 'var(--accent-red)'}">${wr}%</span><span class="stat-label">Win Rate</span></div>
                            <div class="stat-box"><span class="stat-value">${avgPtsF} - ${avgPtsA}</span><span class="stat-label">Avg Score F/A</span></div>
                            <div class="stat-box"><span class="stat-value" style="color: ${parseFloat(kd) >= 1 ? 'var(--accent-green)' : 'var(--accent-red)'}">${kd}</span><span class="stat-label">Team K/D</span></div>
                        </div>
                    </div>`;
            }

            section.innerHTML = `
                <div class="faction-compare">
                    ${factionCol(allies, '‚òÖ Allies', 'faction-allies')}
                    <div class="faction-vs">VS</div>
                    ${factionCol(axis, '‚ú† Axis', 'faction-axis')}
                </div>`;
        }

        function renderVetoHelper(matches) {
            const section = document.getElementById('vetoHelper');
            const mapStats = {};
            matches.forEach(m => {
                const map = m.map;
                if (!map) return;
                if (!mapStats[map]) mapStats[map] = { map, matches: 0, wins: 0 };
                mapStats[map].matches++;
                if (m.result === 'W') mapStats[map].wins++;
            });

            const qualified = Object.values(mapStats).filter(s => s.matches >= 2);
            qualified.forEach(s => s.winRate = Math.round(s.wins / s.matches * 100));
            const picks = [...qualified].sort((a, b) => b.winRate - a.winRate || b.matches - a.matches).slice(0, 3);
            const bans = [...qualified].sort((a, b) => a.winRate - b.winRate || b.matches - a.matches).slice(0, 3);

            if (qualified.length === 0) {
                section.innerHTML = '<div class="text-center text-muted">Need at least 2 games on a map to generate suggestions</div>';
                return;
            }

            function vetoList(items, cls) {
                return items.map(s => `
                    <div class="veto-map ${cls}">
                        <span>${s.map}</span>
                        <span style="display: flex; align-items: center; gap: 8px;">
                            <span class="veto-record">${s.wins}W-${s.matches - s.wins}L</span>
                            <span class="veto-winrate" style="color: ${s.winRate >= 50 ? 'var(--accent-green)' : 'var(--accent-red)'}">${s.winRate}%</span>
                        </span>
                    </div>
                `).join('');
            }

            section.innerHTML = `
                <div class="veto-grid">
                    <div class="veto-section">
                        <h4 style="color: var(--accent-green);">‚úì Pick These</h4>
                        ${vetoList(picks, 'pick')}
                    </div>
                    <div class="veto-section">
                        <h4 style="color: var(--accent-red);">‚úó Ban These</h4>
                        ${vetoList(bans, 'ban')}
                    </div>
                </div>`;
        }

        function renderMapDeepDive(matches, matchKD) {
            const section = document.getElementById('mapDeepDive');
            const mapData = {};
            matches.forEach(m => {
                const map = m.map;
                if (!map) return;
                if (!mapData[map]) mapData[map] = { map, total: 0, wins: 0, losses: 0, ptsFor: 0, ptsAgainst: 0, kills: 0, deaths: 0, factions: {} };
                mapData[map].total++;
                if (m.result === 'W') mapData[map].wins++;
                if (m.result === 'L') mapData[map].losses++;
                mapData[map].ptsFor += m.my_score || 0;
                mapData[map].ptsAgainst += m.enemy_score || 0;
                const kd = matchKD[m.match_id];
                if (kd) { mapData[map].kills += kd.fKills; mapData[map].deaths += kd.fDeaths; }

                const f = m.my_faction || 'Unknown';
                if (!mapData[map].factions[f]) mapData[map].factions[f] = { matches: 0, wins: 0, losses: 0, ptsFor: 0, ptsAgainst: 0 };
                mapData[map].factions[f].matches++;
                if (m.result === 'W') mapData[map].factions[f].wins++;
                if (m.result === 'L') mapData[map].factions[f].losses++;
                mapData[map].factions[f].ptsFor += m.my_score || 0;
                mapData[map].factions[f].ptsAgainst += m.enemy_score || 0;
            });

            const sorted = Object.values(mapData).sort((a, b) => b.total - a.total);

            section.innerHTML = `
                <table class="data-table" style="font-size: 0.85rem;">
                    <thead><tr>
                        <th></th><th>Map</th><th>Played</th><th>W</th><th>L</th><th>Win%</th><th>Avg Score</th><th>Team K/D</th>
                    </tr></thead>
                    <tbody>
                        ${sorted.map((s, i) => {
                            const wr = s.total > 0 ? Math.round(s.wins / s.total * 100) : 0;
                            const avgF = (s.ptsFor / s.total).toFixed(1);
                            const avgA = (s.ptsAgainst / s.total).toFixed(1);
                            const kd = s.deaths > 0 ? (s.kills / s.deaths).toFixed(2) : '-';
                            const wrClass = wr >= 60 ? 'color: var(--accent-green)' : wr < 40 ? 'color: var(--accent-red)' : '';
                            const factionRows = Object.entries(s.factions).map(([f, fd]) => {
                                const fWr = fd.matches > 0 ? Math.round(fd.wins / fd.matches * 100) : 0;
                                const badge = f === 'Allies' ? '<span class="faction-badge faction-allies" style="font-size:10px;">‚òÖ Allies</span>' : '<span class="faction-badge faction-axis" style="font-size:10px;">‚ú† Axis</span>';
                                return `<div class="map-faction-detail" id="mf-${i}-detail" style="display:flex; gap:12px; align-items:center;">
                                    ${badge} <span>${fd.wins}W-${fd.losses}L</span> <span style="font-weight:600; ${fWr >= 50 ? 'color:var(--accent-green)' : 'color:var(--accent-red)'}">${fWr}%</span> <span>${(fd.ptsFor/fd.matches).toFixed(1)}-${(fd.ptsAgainst/fd.matches).toFixed(1)} avg</span>
                                </div>`;
                            }).join('');
                            return `<tr>
                                <td><button class="map-expand-btn" onclick="toggleMapDetail(${i})">‚ñ∏</button></td>
                                <td>${s.map}</td>
                                <td>${s.total}</td>
                                <td style="color: var(--accent-green)">${s.wins}</td>
                                <td style="color: var(--accent-red)">${s.losses}</td>
                                <td style="${wrClass}; font-weight:700;">${wr}%</td>
                                <td>${avgF} - ${avgA}</td>
                                <td style="color: ${parseFloat(kd) >= 1 ? 'var(--accent-green)' : 'var(--accent-red)'}">${kd}</td>
                            </tr>
                            <tr class="map-detail-row" id="mf-${i}-row" style="display:none;">
                                <td colspan="8" style="padding: 4px 8px 8px 30px;">${factionRows}</td>
                            </tr>`;
                        }).join('')}
                    </tbody>
                </table>`;
        }

        function toggleMapDetail(idx) {
            const row = document.getElementById('mf-' + idx + '-row');
            const btn = row?.previousElementSibling?.querySelector('.map-expand-btn');
            if (row) {
                const visible = row.style.display !== 'none';
                row.style.display = visible ? 'none' : 'table-row';
                // Show all faction detail divs inside
                row.querySelectorAll('.map-faction-detail').forEach(el => el.style.display = visible ? 'none' : 'flex');
                if (btn) btn.textContent = visible ? '‚ñ∏' : '‚ñæ';
            }
        }

        function renderPerfOverTime(matches, matchKD) {
            const section = document.getElementById('perfOverTime');
            const months = {};
            matches.forEach(m => {
                const d = m.date || '';
                const month = d.substring(0, 7); // YYYY-MM
                if (!month) return;
                if (!months[month]) months[month] = { month, matches: 0, wins: 0, losses: 0, ptsFor: 0, ptsAgainst: 0, kills: 0, deaths: 0 };
                months[month].matches++;
                if (m.result === 'W') months[month].wins++;
                if (m.result === 'L') months[month].losses++;
                months[month].ptsFor += m.my_score || 0;
                months[month].ptsAgainst += m.enemy_score || 0;
                const kd = matchKD[m.match_id];
                if (kd) { months[month].kills += kd.fKills; months[month].deaths += kd.fDeaths; }
            });

            const sorted = Object.values(months).sort((a, b) => a.month.localeCompare(b.month));
            if (sorted.length === 0) {
                section.innerHTML = '<div class="text-center text-muted">No date data available</div>';
                return;
            }

            // Format month name
            function fmtMonth(m) {
                const [y, mo] = m.split('-');
                const names = ['', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${names[parseInt(mo)] || mo} ${y}`;
            }

            section.innerHTML = `
                <table class="data-table" style="font-size: 0.85rem;">
                    <thead><tr>
                        <th>Month</th><th>Matches</th><th>W</th><th>L</th><th>Win%</th><th>Avg Score</th><th>Team K/D</th><th></th>
                    </tr></thead>
                    <tbody>
                        ${sorted.map(s => {
                            const wr = s.matches > 0 ? Math.round(s.wins / s.matches * 100) : 0;
                            const avgF = (s.ptsFor / s.matches).toFixed(1);
                            const avgA = (s.ptsAgainst / s.matches).toFixed(1);
                            const kd = s.deaths > 0 ? (s.kills / s.deaths).toFixed(2) : '-';
                            const wrClass = wr >= 60 ? 'color: var(--accent-green)' : wr < 40 ? 'color: var(--accent-red)' : '';
                            const barWidth = Math.min(wr, 100);
                            const barColor = wr >= 60 ? 'var(--accent-green)' : wr < 40 ? 'var(--accent-red)' : 'var(--accent-orange)';
                            return `<tr>
                                <td style="font-weight:500;">${fmtMonth(s.month)}</td>
                                <td>${s.matches}</td>
                                <td style="color: var(--accent-green)">${s.wins}</td>
                                <td style="color: var(--accent-red)">${s.losses}</td>
                                <td style="${wrClass}; font-weight:700;">${wr}%</td>
                                <td>${avgF} - ${avgA}</td>
                                <td style="color: ${parseFloat(kd) >= 1 ? 'var(--accent-green)' : 'var(--accent-red)'}">${kd}</td>
                                <td style="width:80px;"><span class="trend-bar" style="width:${barWidth}%; background:${barColor};"></span></td>
                            </tr>`;
                        }).join('')}
                    </tbody>
                </table>`;
        }

        function renderScoreAnalysis(matches) {
            const section = document.getElementById('scoreAnalysis');

            const avgFor = matches.length > 0 ? (matches.reduce((s, m) => s + (m.my_score || 0), 0) / matches.length).toFixed(1) : '-';
            const avgAgainst = matches.length > 0 ? (matches.reduce((s, m) => s + (m.enemy_score || 0), 0) / matches.length).toFixed(1) : '-';

            // Score diff categories
            const categories = [
                { label: 'Close (1 pt diff)', filter: m => Math.abs((m.my_score || 0) - (m.enemy_score || 0)) === 1 },
                { label: 'Standard (2-3 pts)', filter: m => { const d = Math.abs((m.my_score || 0) - (m.enemy_score || 0)); return d >= 2 && d <= 3; } },
                { label: 'Blowout (4-5 pts)', filter: m => Math.abs((m.my_score || 0) - (m.enemy_score || 0)) >= 4 },
                { label: 'Shutout (5-0)', filter: m => (m.my_score === 5 && m.enemy_score === 0) || (m.my_score === 0 && m.enemy_score === 5) },
            ];

            const catHTML = categories.map(c => {
                const catMatches = matches.filter(c.filter);
                const catWins = catMatches.filter(m => m.result === 'W').length;
                const wr = catMatches.length > 0 ? Math.round(catWins / catMatches.length * 100) : 0;
                const wrClass = wr >= 60 ? 'color: var(--accent-green)' : wr < 40 ? 'color: var(--accent-red)' : '';
                return `<div class="score-category">
                    <span class="score-cat-label">${c.label}</span>
                    <span class="score-cat-count">${catMatches.length} games</span>
                    <span style="flex:1;">
                        <div class="win-bar" style="max-width:120px;">
                            <div class="win-bar-fill" style="width: ${wr}%"></div>
                        </div>
                    </span>
                    <span class="score-cat-winrate" style="${wrClass}">${catMatches.length > 0 ? wr + '%' : '-'}</span>
                </div>`;
            }).join('');

            // Biggest win & worst loss
            let biggestWin = null, worstLoss = null;
            matches.forEach(m => {
                const diff = (m.my_score || 0) - (m.enemy_score || 0);
                if (m.result === 'W' && (!biggestWin || diff > biggestWin.diff)) biggestWin = { ...m, diff };
                if (m.result === 'L' && (!worstLoss || diff < worstLoss.diff)) worstLoss = { ...m, diff };
            });

            section.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 16px;">
                    <div class="stat-box"><span class="stat-value">${avgFor}</span><span class="stat-label">Avg Points For</span></div>
                    <div class="stat-box"><span class="stat-value">${avgAgainst}</span><span class="stat-label">Avg Points Against</span></div>
                    ${biggestWin ? `<div class="stat-box"><span class="stat-value" style="color: var(--accent-green)">${biggestWin.my_score}-${biggestWin.enemy_score}</span><span class="stat-label">Biggest Win</span><span style="font-size:10px; color:var(--text-muted);">vs ${biggestWin.enemy_team || '?'}</span></div>` : ''}
                    ${worstLoss ? `<div class="stat-box"><span class="stat-value" style="color: var(--accent-red)">${worstLoss.my_score}-${worstLoss.enemy_score}</span><span class="stat-label">Worst Loss</span><span style="font-size:10px; color:var(--text-muted);">vs ${worstLoss.enemy_team || '?'}</span></div>` : ''}
                </div>
                <div style="margin-top: 4px;">
                    <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 8px;">Win Rate by Score Margin</div>
                    ${catHTML}
                </div>`;
        }

        function renderMatchHistory(matches, enemyRecord) {
            const section = document.getElementById('matchHistory');
            // Show newest first
            const reversed = [...matches].reverse();

            function enemyStrength(enemyTag) {
                const rec = enemyRecord[enemyTag];
                if (!rec || rec.total < 2) return '';
                const wr = Math.round(rec.wins / rec.total * 100);
                let cls = 'medium', tip = `${rec.wins}W-${rec.losses}L (${wr}%)`;
                if (wr >= 65) cls = 'easy';
                if (wr <= 35) cls = 'hard';
                return `<span class="enemy-strength ${cls}" title="${enemyTag}: ${tip}"></span>`;
            }

            function fmtDate(d) {
                if (!d) return '-';
                const dt = new Date(d);
                const day = String(dt.getDate()).padStart(2, '0');
                const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                return `${day} ${months[dt.getMonth()]} ${String(dt.getFullYear()).slice(-2)}`;
            }

            section.innerHTML = `
                <table class="data-table" style="font-size: 0.85rem;">
                    <thead><tr>
                        <th>Date</th><th>Enemy</th><th>Map</th><th>Faction</th><th>Score</th><th>Result</th>
                    </tr></thead>
                    <tbody>
                        ${reversed.map(m => {
                            const factionBadge = m.my_faction === 'Allies'
                                ? '<span class="faction-badge faction-allies" style="font-size:10px;">‚òÖ Allies</span>'
                                : m.my_faction === 'Axis'
                                ? '<span class="faction-badge faction-axis" style="font-size:10px;">‚ú† Axis</span>'
                                : (m.my_faction || '-');
                            return `<tr>
                                <td style="white-space:nowrap;">${fmtDate(m.date)}</td>
                                <td>${m.enemy_team || '-'}${enemyStrength(m.enemy_team)}</td>
                                <td>${m.map || '-'}</td>
                                <td>${factionBadge}</td>
                                <td style="font-weight:600;">${m.my_score ?? '-'}-${m.enemy_score ?? '-'}</td>
                                <td><span class="match-result-badge ${m.result || ''}">${m.result || '-'}</span></td>
                            </tr>`;
                        }).join('')}
                    </tbody>
                </table>
                <div style="font-size:10px; color: var(--text-muted); margin-top: 8px;">
                    Enemy strength: <span class="enemy-strength easy" style="display:inline-block;"></span> favourable
                    <span class="enemy-strength medium" style="display:inline-block; margin-left:6px;"></span> even
                    <span class="enemy-strength hard" style="display:inline-block; margin-left:6px;"></span> tough
                    <span style="margin-left:6px;">(based on overall record, min 2 games)</span>
                </div>`;
        }

        init();
    </script>
</body>
</html>

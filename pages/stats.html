<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stats - HLL Tool v0.6.8</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 16px;
        }
        
        /* Award cards grid */
        .awards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }
        .award-card {
            background: var(--bg-secondary); border: 1px solid var(--border-color);
            border-radius: 8px; padding: 12px; transition: border-color 0.2s;
        }
        .award-card:hover { border-color: var(--accent-orange); }
        .award-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .award-title { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .award-icon { font-size: 16px; }
        .award-winner { font-size: 15px; font-weight: 700; color: var(--text-primary); margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .award-stat { font-size: 12px; color: var(--text-secondary); }
        .award-stat .highlight { color: var(--accent-green); font-weight: 600; }
        .award-empty { font-size: 12px; color: var(--text-muted); font-style: italic; }
        .award-expand { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 10px; padding: 2px 0; margin-top: 6px; transition: color 0.15s; }
        .award-expand:hover { color: var(--accent-orange); }
        .award-runners { display: none; margin-top: 6px; border-top: 1px solid var(--border-color); padding-top: 6px; }
        .award-runners.visible { display: block; }
        .runner-row { display: flex; justify-content: space-between; padding: 2px 0; font-size: 11px; }
        .runner-rank { color: var(--text-muted); width: 18px; }
        .runner-name { flex: 1; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .runner-stat { color: var(--text-muted); margin-left: 8px; }
        
        .section-title {
            font-size: 16px; font-weight: 700; color: var(--text-primary);
            margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color);
        }
        
        .win-bar {
            display: flex;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            background: var(--bg-tertiary);
            margin-top: 4px;
        }
        
        .win-bar-fill {
            background: var(--accent-green);
            transition: width 0.3s ease;
        }
        
        .faction-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .faction-allies {
            background: rgba(56, 139, 253, 0.2);
            color: var(--accent-blue);
        }
        
        .faction-axis {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }
        
        .map-row {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .map-row:last-child {
            border-bottom: none;
        }
        
        .map-name {
            flex: 1;
            font-weight: 500;
        }
        
        .map-stats {
            display: flex;
            gap: 16px;
            align-items: center;
        }
        
        .map-record {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 60px;
            text-align: center;
        }
        
        .map-winrate {
            font-weight: 700;
            min-width: 50px;
            text-align: right;
        }
        
        .enemy-row {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .enemy-row:last-child {
            border-bottom: none;
        }
        
        .enemy-name {
            flex: 1;
            font-weight: 500;
        }
        
        .enemy-stats {
            display: flex;
            gap: 24px;
            align-items: center;
        }
        
        .points-diff {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .points-diff.positive {
            background: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }
        
        .points-diff.negative {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }
        
        .role-bar-row {
            display: flex;
            align-items: center;
            padding: 6px 0;
            gap: 10px;
        }
        
        .role-bar-label {
            min-width: 90px;
            font-size: 13px;
            font-weight: 500;
        }
        
        .role-bar-track {
            flex: 1;
            height: 14px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .role-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .role-bar-value {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav-bar">
        <a href="../index.html" class="nav-logo">HLL Tool</a>
        <div class="nav-links">
            <a href="../index.html" class="nav-link">Home</a>
            <a href="lineup.html" class="nav-link">Lineups</a>
            <a href="roster.html" class="nav-link">Roster</a>
            <a href="stats.html" class="nav-link active">Stats</a>
            <a href="matches.html" class="nav-link">Matches</a>
            <a href="enemies.html" class="nav-link">Enemy Intel</a>
            <a href="admin.html" class="nav-link">Admin</a>
        </div>
        <div class="nav-spacer"></div>
        <div class="nav-status">
            <span class="status-dot"></span>
            <span>Connecting...</span>
        </div>
    </nav>

    <div class="app-container">
        <!-- Header -->
        <div class="page-header">
            <h1 class="page-title">Team Stats</h1>
            <span class="version-badge">v0.6.8</span>
        </div>

        <!-- Tabs -->
        <div style="display: flex; gap: 0; margin-bottom: 20px; border-bottom: 2px solid rgba(255,255,255,0.1);">
            <div class="stats-tab active" onclick="switchStatsTab('players')" id="tab-btn-players" style="padding: 10px 20px; cursor: pointer; color: var(--accent-orange); border-bottom: 2px solid var(--accent-orange); margin-bottom: -2px; font-weight: 600;">Player Stats</div>
            <div class="stats-tab" onclick="switchStatsTab('compare')" id="tab-btn-compare" style="padding: 10px 20px; cursor: pointer; color: var(--text-secondary); border-bottom: 2px solid transparent; margin-bottom: -2px;">Team Compare</div>
        </div>

        <!-- PLAYER STATS TAB (existing content) -->
        <div id="tab-players">

        <!-- Overall Stats -->
        <div class="stat-row" id="overallStats">
            <div class="stat-box">
                <span class="stat-value" id="totalMatches">-</span>
                <span class="stat-label">Total Matches</span>
            </div>
            <div class="stat-box">
                <span class="stat-value" id="totalWins">-</span>
                <span class="stat-label">Wins</span>
            </div>
            <div class="stat-box">
                <span class="stat-value" id="totalLosses">-</span>
                <span class="stat-label">Losses</span>
            </div>
            <div class="stat-box">
                <span class="stat-value" id="overallWinRate">-</span>
                <span class="stat-label">Win Rate</span>
            </div>
            <div class="stat-box">
                <span class="stat-value" id="pointsFor">-</span>
                <span class="stat-label">Points For</span>
            </div>
            <div class="stat-box">
                <span class="stat-value" id="pointsAgainst">-</span>
                <span class="stat-label">Points Against</span>
            </div>
        </div>

        <div class="stats-grid">
            <!-- Map Stats - Allies -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">
                        <span class="faction-badge faction-allies">‚òÖ Allies</span>
                        Map Performance
                    </span>
                </div>
                <div class="card-body" id="mapStatsAllies">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>

            <!-- Map Stats - Axis -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">
                        <span class="faction-badge faction-axis">‚ú† Axis</span>
                        Map Performance
                    </span>
                </div>
                <div class="card-body" id="mapStatsAxis">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Enemy Team Stats -->
        <div class="card mt-lg">
            <div class="card-header">
                <span class="card-title">üéØ Enemy Team Records</span>
            </div>
            <div class="card-body" id="enemyStats">
                <div class="text-center text-muted">Loading...</div>
            </div>
        </div>

        <!-- Role Leaders -->
        <div class="mt-lg">
            <div class="section-title">üéñÔ∏è Role Leaders</div>
            <div class="awards-grid" id="roleLeaderCards">
                <div class="text-center text-muted" style="grid-column: 1/-1;">Loading...</div>
            </div>
        </div>

        <!-- Achievement Awards -->
        <div class="mt-lg">
            <div class="section-title">üèÖ Achievements</div>
            <div class="awards-grid" id="achievementCards">
                <div class="text-center text-muted" style="grid-column: 1/-1;">Loading...</div>
            </div>
        </div>

        <!-- Top Players -->
        <div class="stats-grid mt-lg">
            <!-- Top Killers -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">üèÜ Top Killers (Avg)</span>
                </div>
                <div class="card-body">
                    <table class="data-table" id="topKillersTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Player</th>
                                <th class="numeric">Avg Kills</th>
                                <th class="numeric">Matches</th>
                            </tr>
                        </thead>
                        <tbody id="topKillersBody">
                            <tr><td colspan="4" class="text-center text-muted">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Top K/D -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">‚öîÔ∏è Top K/D Ratio</span>
                </div>
                <div class="card-body">
                    <table class="data-table" id="topKDTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Player</th>
                                <th class="numeric">K/D</th>
                                <th class="numeric">Matches</th>
                            </tr>
                        </thead>
                        <tbody id="topKDBody">
                            <tr><td colspan="4" class="text-center text-muted">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Top MVPs -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">üåü Most MVPs</span>
                </div>
                <div class="card-body">
                    <table class="data-table" id="topMVPTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Player</th>
                                <th class="numeric">MVPs</th>
                                <th class="numeric">Matches</th>
                            </tr>
                        </thead>
                        <tbody id="topMVPBody">
                            <tr><td colspan="4" class="text-center text-muted">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Best Attendance -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">üìÖ Best Attendance</span>
                </div>
                <div class="card-body">
                    <table class="data-table" id="topAttendanceTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Player</th>
                                <th class="numeric">Attend%</th>
                                <th class="numeric">Matches</th>
                            </tr>
                        </thead>
                        <tbody id="topAttendanceBody">
                            <tr><td colspan="4" class="text-center text-muted">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Role Leaderboards -->
        <div class="card mt-lg">
            <div class="card-header">
                <span class="card-title">üéØ Role Leaderboards (PPS)</span>
                <select id="roleGroupFilter" style="background: var(--bg-input, #1a1a2e); border: 1px solid rgba(255,255,255,0.15); border-radius: 4px; color: var(--text-primary); padding: 4px 8px; font-size: 0.85rem;">
                    <option value="">Select role...</option>
                    <option value="Infantry">Infantry</option>
                    <option value="Squad Leader">Squad Leader</option>
                    <option value="Defence">Defence</option>
                    <option value="Defence SL">Defence SL</option>
                    <option value="Spotter">Spotter</option>
                    <option value="Sniper">Sniper</option>
                    <option value="Tank Crew">Tank Crew</option>
                    <option value="Commander">Commander</option>
                    <option value="Artillery">Artillery</option>
                </select>
            </div>
            <div class="card-body" id="roleLeaderboard">
                <div class="text-center text-muted">Select a role to see player rankings by PPS</div>
            </div>
        </div>

        </div><!-- end tab-players -->

        <!-- TEAM COMPARE TAB -->
        <div id="tab-compare" style="display: none;">
            
            <!-- My Team Summary -->
            <div class="card">
                <div class="card-header"><span class="card-title">üìä My Team Summary</span></div>
                <div class="card-body" id="myTeamSummary">
                    <div class="text-center text-muted">Loading...</div>
                </div>
            </div>

            <!-- Division Rankings -->
            <div class="card mt-lg">
                <div class="card-header">
                    <span class="card-title">üèÜ Division Rankings</span>
                    <select id="divisionFilter" style="background: var(--bg-input, #1a1a2e); border: 1px solid rgba(255,255,255,0.15); border-radius: 4px; color: var(--text-primary); padding: 4px 8px; font-size: 0.85rem;">
                        <option value="">Select division...</option>
                    </select>
                </div>
                <div class="card-body" id="divisionRankings">
                    <div class="text-center text-muted">Select a division to see rankings</div>
                </div>
            </div>

            <!-- Head-to-Head -->
            <div class="card mt-lg">
                <div class="card-header">
                    <span class="card-title">‚öîÔ∏è Head-to-Head</span>
                    <select id="h2hTeamSelect" style="background: var(--bg-input, #1a1a2e); border: 1px solid rgba(255,255,255,0.15); border-radius: 4px; color: var(--text-primary); padding: 4px 8px; font-size: 0.85rem;">
                        <option value="">Select enemy team...</option>
                    </select>
                </div>
                <div class="card-body" id="headToHead">
                    <div class="text-center text-muted">Select an enemy team for head-to-head comparison</div>
                </div>
            </div>

            <!-- Player-level Comparison -->
            <div id="playerCompareSection" style="display: none;">
                <div class="card mt-lg">
                    <div class="card-header"><span class="card-title">üë• Player Comparison ‚Äî Top 10</span></div>
                    <div class="card-body" id="playerCompare">
                        <div class="text-center text-muted">Loading...</div>
                    </div>
                </div>
            </div>

        </div><!-- end tab-compare -->

    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay hidden" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading...</div>
    </div>

    <script src="../js/hll.js"></script>
    <script>
        async function init() {
            HLL.showLoading('Loading stats...');
            await HLL.init();
            
            if (HLL.isOnline) {
                await Promise.all([
                    loadOverallStats(),
                    loadMapStats(),
                    loadEnemyStats(),
                    loadPlayerLeaderboards(),
                    loadAwardCards()
                ]);
                initRoleLeaderboard();
            }
            
            HLL.hideLoading();
        }
        
        async function loadOverallStats() {
            try {
                const matches = await HLL.loadMatches(1000);
                
                const wins = matches.filter(m => m.result === 'W').length;
                const losses = matches.filter(m => m.result === 'L').length;
                const pointsFor = matches.reduce((sum, m) => sum + (m.my_score || 0), 0);
                const pointsAgainst = matches.reduce((sum, m) => sum + (m.enemy_score || 0), 0);
                const winRate = matches.length > 0 ? Math.round((wins / matches.length) * 100) : 0;
                
                document.getElementById('totalMatches').textContent = matches.length;
                document.getElementById('totalWins').textContent = wins;
                document.getElementById('totalLosses').textContent = losses;
                document.getElementById('overallWinRate').textContent = winRate + '%';
                document.getElementById('pointsFor').textContent = pointsFor;
                document.getElementById('pointsAgainst').textContent = pointsAgainst;
            } catch (err) {
                console.error('Error loading overall stats:', err);
            }
        }
        
        async function loadMapStats() {
            try {
                const matches = await HLL.loadMatches(1000);
                const mapStats = {};
                
                matches.forEach(m => {
                    const key = `${m.map}-${m.my_faction}`;
                    if (!mapStats[key]) {
                        mapStats[key] = { map: m.map, faction: m.my_faction, matches: 0, wins: 0, losses: 0 };
                    }
                    mapStats[key].matches++;
                    if (m.result === 'W') mapStats[key].wins++;
                    if (m.result === 'L') mapStats[key].losses++;
                });
                
                const alliesStats = Object.values(mapStats).filter(s => s.faction === 'Allies').sort((a, b) => b.matches - a.matches);
                const axisStats = Object.values(mapStats).filter(s => s.faction === 'Axis').sort((a, b) => b.matches - a.matches);
                
                renderMapStats('mapStatsAllies', alliesStats);
                renderMapStats('mapStatsAxis', axisStats);
            } catch (err) {
                console.error('Error loading map stats:', err);
            }
        }
        
        function renderMapStats(containerId, stats) {
            const container = document.getElementById(containerId);
            
            if (stats.length === 0) {
                container.innerHTML = '<div class="text-center text-muted">No matches yet</div>';
                return;
            }
            
            container.innerHTML = stats.map(s => {
                const winRate = s.matches > 0 ? Math.round((s.wins / s.matches) * 100) : 0;
                const winRateClass = winRate >= 60 ? 'text-success' : (winRate < 40 ? 'text-danger' : '');
                
                return `
                    <div class="map-row">
                        <span class="map-name">${s.map}</span>
                        <div class="map-stats">
                            <span class="map-record">${s.wins}W - ${s.losses}L</span>
                            <span class="map-winrate ${winRateClass}">${winRate}%</span>
                        </div>
                    </div>
                    <div class="win-bar">
                        <div class="win-bar-fill" style="width: ${winRate}%"></div>
                    </div>
                `;
            }).join('');
        }
        
        async function loadEnemyStats() {
            try {
                const matches = await HLL.loadMatches(1000);
                const enemyStats = {};
                
                matches.forEach(m => {
                    const enemy = m.enemy_team;
                    if (!enemyStats[enemy]) {
                        enemyStats[enemy] = { enemy, matches: 0, wins: 0, losses: 0, pointsFor: 0, pointsAgainst: 0 };
                    }
                    enemyStats[enemy].matches++;
                    if (m.result === 'W') enemyStats[enemy].wins++;
                    if (m.result === 'L') enemyStats[enemy].losses++;
                    enemyStats[enemy].pointsFor += m.my_score || 0;
                    enemyStats[enemy].pointsAgainst += m.enemy_score || 0;
                });
                
                const sorted = Object.values(enemyStats).sort((a, b) => b.matches - a.matches);
                renderEnemyStats(sorted);
            } catch (err) {
                console.error('Error loading enemy stats:', err);
            }
        }
        
        function renderEnemyStats(stats) {
            const container = document.getElementById('enemyStats');
            
            if (stats.length === 0) {
                container.innerHTML = '<div class="text-center text-muted">No matches yet</div>';
                return;
            }
            
            container.innerHTML = stats.map(s => {
                const winRate = s.matches > 0 ? Math.round((s.wins / s.matches) * 100) : 0;
                const winRateClass = winRate >= 60 ? 'text-success' : (winRate < 40 ? 'text-danger' : '');
                const pointsDiff = s.pointsFor - s.pointsAgainst;
                const pointsDiffClass = pointsDiff > 0 ? 'positive' : (pointsDiff < 0 ? 'negative' : '');
                const pointsDiffText = pointsDiff > 0 ? `+${pointsDiff}` : pointsDiff;
                
                return `
                    <div class="enemy-row">
                        <span class="enemy-name">${s.enemy}</span>
                        <div class="enemy-stats">
                            <span style="min-width: 80px;">${s.matches} matches</span>
                            <span style="min-width: 80px;">${s.wins}W - ${s.losses}L</span>
                            <span class="map-winrate ${winRateClass}" style="min-width: 50px;">${winRate}%</span>
                            <span class="points-diff ${pointsDiffClass}">${pointsDiffText} pts</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        async function loadPlayerLeaderboards() {
            try {
                const players = await HLL.loadPlayers();
                const qualified = players.filter(p => p.total_matches >= 3);
                
                // Top Killers
                const topKillers = [...qualified].sort((a, b) => (b.avg_kills || 0) - (a.avg_kills || 0)).slice(0, 10);
                renderLeaderboard('topKillersBody', topKillers, 'avg_kills');
                
                // Top K/D
                const topKD = [...qualified]
                    .map(p => ({ ...p, kd: p.total_deaths > 0 ? (p.total_kills / p.total_deaths) : 0 }))
                    .sort((a, b) => b.kd - a.kd).slice(0, 10);
                renderLeaderboard('topKDBody', topKD, 'kd', 2);
                
                // Top MVPs
                const topMVP = [...players].sort((a, b) => (b.mvp_count || 0) - (a.mvp_count || 0)).filter(p => p.mvp_count > 0).slice(0, 10);
                renderLeaderboard('topMVPBody', topMVP, 'mvp_count');
                
                // Best Attendance
                const topAttendance = [...players]
                    .filter(p => (p.total_matches + (p.no_shows || 0)) >= 5)
                    .map(p => ({ ...p, attendance: p.total_matches / (p.total_matches + (p.no_shows || 0)) * 100 }))
                    .sort((a, b) => b.attendance - a.attendance).slice(0, 10);
                renderLeaderboard('topAttendanceBody', topAttendance, 'attendance', 0, '%');
            } catch (err) {
                console.error('Error loading leaderboards:', err);
            }
        }
        
        function renderLeaderboard(tableId, players, statKey, decimals = 1, suffix = '') {
            const tbody = document.getElementById(tableId);
            
            if (players.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">No data</td></tr>';
                return;
            }
            
            tbody.innerHTML = players.map((p, i) => `
                <tr>
                    <td class="center">${i + 1}</td>
                    <td>${HLL.formatPlayerName(p.name, p.team)}</td>
                    <td class="numeric">${(p[statKey] || 0).toFixed(decimals)}${suffix}</td>
                    <td class="numeric">${p.total_matches || 0}</td>
                </tr>
            `).join('');
        }
        
        // ============================================================================
        // AWARD CARDS
        // ============================================================================
        
        function renderAwardCard(icon, title, players, statFn, id) {
            if (!players || players.length === 0) {
                return `<div class="award-card"><div class="award-header"><span class="award-title">${title}</span><span class="award-icon">${icon}</span></div><div class="award-empty">Not enough data</div></div>`;
            }
            const winner = players[0];
            const runners = players.slice(1, 10);
            const runnersId = 'runners-' + id;
            return `<div class="award-card">
                <div class="award-header"><span class="award-title">${title}</span><span class="award-icon">${icon}</span></div>
                <div class="award-winner">${winner.name}</div>
                <div class="award-stat">${statFn(winner)}</div>
                ${runners.length > 0 ? `<button class="award-expand" onclick="toggleRunners('${runnersId}')">‚ñ∏ Top ${runners.length + 1}</button>
                <div class="award-runners" id="${runnersId}">
                    ${runners.map((p, i) => `<div class="runner-row"><span class="runner-rank">#${i + 2}</span><span class="runner-name">${p.name}</span><span class="runner-stat">${statFn(p)}</span></div>`).join('')}
                </div>` : ''}
            </div>`;
        }
        
        function toggleRunners(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.toggle('visible');
                const btn = el.previousElementSibling;
                if (btn) btn.textContent = el.classList.contains('visible') ? '‚ñæ Collapse' : '‚ñ∏ Top 10';
            }
        }
        
        async function loadAwardCards() {
            try {
                // Fetch all data we need
                const [detailsRes, lineupsRes, playersRes, matchesRes] = await Promise.all([
                    HLL.supabase.from('match_details').select('*').eq('team', 'Friendly'),
                    HLL.supabase.from('match_lineups').select('*'),
                    HLL.supabase.from('players').select('*'),
                    HLL.supabase.from('matches').select('match_id, date, result')
                ]);
                
                const details = detailsRes.data || [];
                const lineups = lineupsRes.data || [];
                const allPlayers = playersRes.data || [];
                const matches = matchesRes.data || [];
                
                if (details.length === 0 && lineups.length === 0) {
                    document.getElementById('roleLeaderCards').innerHTML = '<div class="text-center text-muted" style="grid-column:1/-1">Import match data to see role leaders</div>';
                    document.getElementById('achievementCards').innerHTML = '<div class="text-center text-muted" style="grid-column:1/-1">Import match data to see achievements</div>';
                    return;
                }
                
                // === BUILD PLAYER STAT MAPS ===
                
                // Per-player match stats from match_details
                const playerStats = {};
                details.forEach(d => {
                    const key = d.steam_id || d.player_name;
                    if (!playerStats[key]) playerStats[key] = { name: d.player_name, matches: [], steamId: d.steam_id };
                    playerStats[key].matches.push(d);
                });
                
                // Per-player role counts from match_lineups
                const playerRoles = {};
                lineups.forEach(l => {
                    const key = l.steam_id || l.player_name;
                    if (!playerRoles[key]) playerRoles[key] = { name: l.player_name, roles: {}, sections: {}, matchIds: new Set() };
                    const role = l.role || 'Unknown';
                    const section = l.section || '';
                    playerRoles[key].roles[role] = (playerRoles[key].roles[role] || 0) + 1;
                    if (section) playerRoles[key].sections[section] = (playerRoles[key].sections[section] || 0) + 1;
                    playerRoles[key].matchIds.add(l.match_id);
                });
                
                // Helper: get avg stat for players with a specific role
                function topByRole(roleName, minMatches = 1) {
                    const candidates = [];
                    Object.entries(playerRoles).forEach(([key, pr]) => {
                        if (!pr.roles[roleName]) return;
                        const ps = playerStats[key];
                        if (!ps || ps.matches.length < minMatches) return;
                        // Get only matches where they played this role
                        const roleMatchIds = new Set();
                        lineups.filter(l => (l.steam_id || l.player_name) === key && l.role === roleName).forEach(l => roleMatchIds.add(l.match_id));
                        const roleMatches = ps.matches.filter(m => roleMatchIds.has(m.match_id));
                        if (roleMatches.length === 0) return;
                        const avgKills = roleMatches.reduce((s, m) => s + (m.kills || 0), 0) / roleMatches.length;
                        const avgDeaths = roleMatches.reduce((s, m) => s + (m.deaths || 0), 0) / roleMatches.length;
                        const avgCE = roleMatches.reduce((s, m) => s + (m.combat_eff || 0), 0) / roleMatches.length;
                        const avgSupport = roleMatches.reduce((s, m) => s + (m.support_pts || 0), 0) / roleMatches.length;
                        const avgDef = roleMatches.reduce((s, m) => s + (m.defensive_pts || 0), 0) / roleMatches.length;
                        candidates.push({
                            name: pr.name, games: roleMatches.length,
                            avgKills: avgKills.toFixed(1), avgDeaths: avgDeaths.toFixed(1),
                            avgCE: avgCE.toFixed(0), avgSupport: avgSupport.toFixed(0), avgDef: avgDef.toFixed(0),
                            kd: avgDeaths > 0 ? (avgKills / avgDeaths).toFixed(2) : avgKills.toFixed(2)
                        });
                    });
                    return candidates.sort((a, b) => parseFloat(b.kd) - parseFloat(a.kd));
                }
                
                // Helper: top by section (Defence squads)
                function topBySection(sectionMatch, minMatches = 1) {
                    const candidates = [];
                    Object.entries(playerRoles).forEach(([key, pr]) => {
                        const sectionCount = Object.entries(pr.sections)
                            .filter(([s]) => s.toLowerCase().includes(sectionMatch.toLowerCase()))
                            .reduce((sum, [, c]) => sum + c, 0);
                        if (sectionCount === 0) return;
                        const ps = playerStats[key];
                        if (!ps || ps.matches.length < minMatches) return;
                        const avgKills = ps.matches.reduce((s, m) => s + (m.kills || 0), 0) / ps.matches.length;
                        const avgDeaths = ps.matches.reduce((s, m) => s + (m.deaths || 0), 0) / ps.matches.length;
                        candidates.push({
                            name: pr.name, games: sectionCount,
                            avgKills: avgKills.toFixed(1),
                            kd: avgDeaths > 0 ? (avgKills / avgDeaths).toFixed(2) : avgKills.toFixed(2)
                        });
                    });
                    return candidates.sort((a, b) => parseFloat(b.kd) - parseFloat(a.kd));
                }
                
                // === ROLE LEADERS ===
                const topCmd = topByRole('Commander');
                const topDefSL = topByRole('Defence');  // Defence SL entries
                const topDefInf = topBySection('defence');
                const topTC = topByRole('TC');
                const topTankCrew = [...(topByRole('Gunner')), ...(topByRole('Driver'))].sort((a, b) => parseFloat(b.kd) - parseFloat(a.kd));
                const topRecon = [...(topByRole('Spotter')), ...(topByRole('Sniper'))].sort((a, b) => parseFloat(b.kd) - parseFloat(a.kd));
                
                // Squad Backbone: most games as any SL role
                const slBackbone = Object.entries(playerRoles).map(([key, pr]) => {
                    const slGames = Object.entries(pr.roles).filter(([r]) => r.includes('SL') || r === 'Commander').reduce((s, [, c]) => s + c, 0);
                    return { name: pr.name, games: slGames };
                }).filter(p => p.games > 0).sort((a, b) => b.games - a.games);
                
                // Rising Star: best K/D with < 5 matches
                const risingStars = Object.values(playerStats)
                    .filter(ps => ps.matches.length >= 1 && ps.matches.length < 5)
                    .map(ps => {
                        const avgK = ps.matches.reduce((s, m) => s + (m.kills || 0), 0) / ps.matches.length;
                        const avgD = ps.matches.reduce((s, m) => s + (m.deaths || 0), 0) / ps.matches.length;
                        return { name: ps.name, games: ps.matches.length, avgKills: avgK.toFixed(1), kd: avgD > 0 ? (avgK / avgD).toFixed(2) : avgK.toFixed(2) };
                    }).sort((a, b) => parseFloat(b.kd) - parseFloat(a.kd));
                
                const roleHTML = [
                    renderAwardCard('üéñÔ∏è', 'Top Commander', topCmd, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.avgKills} avg kills ¬∑ ${p.games} games`, 'cmd'),
                    renderAwardCard('üì£', 'Top SL', topByRole('SL'), p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.avgKills} avg kills ¬∑ ${p.games} games`, 'sl'),
                    renderAwardCard('üõ°Ô∏è', 'Top Defence SL', topDefSL, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.avgDef} def pts ¬∑ ${p.games} games`, 'defsl'),
                    renderAwardCard('üè∞', 'Top Defence Inf', topDefInf, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.games} games`, 'definf'),
                    renderAwardCard('üéØ', 'Top TC', topTC, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.avgKills} avg kills ¬∑ ${p.games} games`, 'tc'),
                    renderAwardCard('üîß', 'Top Tank Crew', topTankCrew, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.games} games`, 'tank'),
                    renderAwardCard('üî≠', 'Top Recon', topRecon, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.games} games`, 'recon'),
                    renderAwardCard('üì¢', 'Squad Backbone', slBackbone, p => `<span class="highlight">${p.games}</span> games as SL/CMD`, 'backbone'),
                    renderAwardCard('‚≠ê', 'Rising Star', risingStars, p => `<span class="highlight">${p.kd}</span> K/D ¬∑ ${p.avgKills} avg kills ¬∑ ${p.games} games`, 'rising'),
                ].join('');
                
                document.getElementById('roleLeaderCards').innerHTML = roleHTML;
                
                // === ACHIEVEMENTS ===
                
                // Top Support (avg support points)
                const topSupport = Object.values(playerStats)
                    .filter(ps => ps.matches.length >= 1)
                    .map(ps => {
                        const avg = ps.matches.reduce((s, m) => s + (m.support_pts || 0), 0) / ps.matches.length;
                        return { name: ps.name, games: ps.matches.length, avgSupport: avg.toFixed(0) };
                    }).sort((a, b) => parseFloat(b.avgSupport) - parseFloat(a.avgSupport));
                
                // Most Improved: compare first half vs second half of matches by date
                const mostImproved = Object.values(playerStats)
                    .filter(ps => ps.matches.length >= 4)
                    .map(ps => {
                        const sorted = [...ps.matches].sort((a, b) => (a.match_id || '').localeCompare(b.match_id || ''));
                        const half = Math.floor(sorted.length / 2);
                        const earlyKD = sorted.slice(0, half);
                        const lateKD = sorted.slice(half);
                        const earlyAvg = earlyKD.reduce((s, m) => s + (m.kills || 0), 0) / earlyKD.length;
                        const lateAvg = lateKD.reduce((s, m) => s + (m.kills || 0), 0) / lateKD.length;
                        const improvement = lateAvg - earlyAvg;
                        return { name: ps.name, games: ps.matches.length, improvement: improvement.toFixed(1), earlyAvg: earlyAvg.toFixed(1), lateAvg: lateAvg.toFixed(1) };
                    }).filter(p => parseFloat(p.improvement) > 0).sort((a, b) => parseFloat(b.improvement) - parseFloat(a.improvement));
                
                // Iron Man: longest attendance streak (consecutive matches)
                const matchDates = matches.sort((a, b) => (a.date || '').localeCompare(b.date || ''));
                const matchOrder = matchDates.map(m => m.match_id);
                const ironMan = Object.values(playerStats)
                    .filter(ps => ps.matches.length >= 2)
                    .map(ps => {
                        const playerMatchIds = new Set(ps.matches.map(m => m.match_id));
                        let maxStreak = 0, streak = 0;
                        matchOrder.forEach(mid => {
                            if (playerMatchIds.has(mid)) { streak++; maxStreak = Math.max(maxStreak, streak); }
                            else { streak = 0; }
                        });
                        return { name: ps.name, games: ps.matches.length, streak: maxStreak };
                    }).sort((a, b) => b.streak - a.streak);
                
                // Most Versatile: most unique roles played
                const versatile = Object.entries(playerRoles)
                    .map(([key, pr]) => ({ name: pr.name, roles: Object.keys(pr.roles).length, roleList: Object.keys(pr.roles).join(', '), games: pr.matchIds.size }))
                    .sort((a, b) => b.roles - a.roles);
                
                // The Reliable: best attendance with 10+ matches
                const reliable = allPlayers
                    .filter(p => (p.total_matches || 0) >= 10 && p.total_matches + (p.no_shows || 0) > 0)
                    .map(p => {
                        const pct = Math.round(p.total_matches / (p.total_matches + (p.no_shows || 0)) * 100);
                        return { name: p.name, games: p.total_matches, pct };
                    }).sort((a, b) => b.pct - a.pct || b.games - a.games);
                
                // The Veteran: most matches
                const veteran = allPlayers
                    .filter(p => (p.total_matches || 0) > 0)
                    .map(p => ({ name: p.name, games: p.total_matches || 0 }))
                    .sort((a, b) => b.games - a.games);
                
                // Node King: most games as Engineer/Support in node sections
                const nodeKing = Object.entries(playerRoles)
                    .map(([key, pr]) => {
                        const nodeGames = Object.entries(pr.sections)
                            .filter(([s]) => s.toLowerCase().includes('node'))
                            .reduce((sum, [, c]) => sum + c, 0);
                        return { name: pr.name, games: nodeGames };
                    }).filter(p => p.games > 0).sort((a, b) => b.games - a.games);
                
                // The Anchor: most games on defence squads
                const anchor = Object.entries(playerRoles)
                    .map(([key, pr]) => {
                        const defGames = Object.entries(pr.sections)
                            .filter(([s]) => s.toLowerCase().includes('defen'))
                            .reduce((sum, [, c]) => sum + c, 0)
                            + (pr.roles['Defence'] || 0);
                        return { name: pr.name, games: defGames };
                    }).filter(p => p.games > 0).sort((a, b) => b.games - a.games);
                
                // Always There: same as Iron Man but current streak
                const alwaysThere = Object.values(playerStats)
                    .filter(ps => ps.matches.length >= 1)
                    .map(ps => {
                        const playerMatchIds = new Set(ps.matches.map(m => m.match_id));
                        let streak = 0;
                        for (let i = matchOrder.length - 1; i >= 0; i--) {
                            if (playerMatchIds.has(matchOrder[i])) streak++;
                            else break;
                        }
                        return { name: ps.name, games: ps.matches.length, streak };
                    }).filter(p => p.streak > 0).sort((a, b) => b.streak - a.streak);
                
                // Team Player: highest avg support as non-SL
                const teamPlayer = Object.entries(playerRoles).map(([key, pr]) => {
                    const nonSLMatchIds = new Set();
                    lineups.filter(l => (l.steam_id || l.player_name) === key && !l.role?.includes('SL') && l.role !== 'Commander')
                        .forEach(l => nonSLMatchIds.add(l.match_id));
                    if (nonSLMatchIds.size === 0) return null;
                    const ps = playerStats[key];
                    if (!ps) return null;
                    const relevantMatches = ps.matches.filter(m => nonSLMatchIds.has(m.match_id));
                    if (relevantMatches.length === 0) return null;
                    const avgSup = relevantMatches.reduce((s, m) => s + (m.support_pts || 0), 0) / relevantMatches.length;
                    return { name: pr.name, games: relevantMatches.length, avgSupport: avgSup.toFixed(0) };
                }).filter(Boolean).sort((a, b) => parseFloat(b.avgSupport) - parseFloat(a.avgSupport));
                
                const achieveHTML = [
                    renderAwardCard('üí™', 'Top Support', topSupport, p => `<span class="highlight">${p.avgSupport}</span> avg support ¬∑ ${p.games} games`, 'support'),
                    renderAwardCard('üìà', 'Most Improved', mostImproved, p => `<span class="highlight">+${p.improvement}</span> avg kills ¬∑ ${p.earlyAvg} ‚Üí ${p.lateAvg}`, 'improved'),
                    renderAwardCard('üî•', 'Iron Man', ironMan, p => `<span class="highlight">${p.streak}</span> match streak ¬∑ ${p.games} total`, 'ironman'),
                    renderAwardCard('üé≠', 'Most Versatile', versatile, p => `<span class="highlight">${p.roles}</span> roles ¬∑ ${p.games} games`, 'versatile'),
                    renderAwardCard('‚úÖ', 'The Reliable', reliable, p => `<span class="highlight">${p.pct}%</span> attendance ¬∑ ${p.games} matches`, 'reliable'),
                    renderAwardCard('üëë', 'The Veteran', veteran, p => `<span class="highlight">${p.games}</span> matches played`, 'veteran'),
                    renderAwardCard('‚ö°', 'Node King', nodeKing, p => `<span class="highlight">${p.games}</span> node assignments`, 'nodeking'),
                    renderAwardCard('‚öì', 'The Anchor', anchor, p => `<span class="highlight">${p.games}</span> defence assignments`, 'anchor'),
                    renderAwardCard('üèÖ', 'Always There', alwaysThere, p => `<span class="highlight">${p.streak}</span> current streak ¬∑ ${p.games} total`, 'always'),
                    renderAwardCard('ü§ù', 'Team Player', teamPlayer, p => `<span class="highlight">${p.avgSupport}</span> avg support (non-SL) ¬∑ ${p.games} games`, 'teamplayer'),
                ].join('');
                
                document.getElementById('achievementCards').innerHTML = achieveHTML;
                
            } catch (err) {
                console.error('Error loading award cards:', err);
                document.getElementById('roleLeaderCards').innerHTML = '<div class="text-center text-muted" style="grid-column:1/-1">Error loading role leaders</div>';
                document.getElementById('achievementCards').innerHTML = '<div class="text-center text-muted" style="grid-column:1/-1">Error loading achievements</div>';
            }
        }
        
        // ============================================================================
        // ROLE LEADERBOARDS
        // ============================================================================
        function initRoleLeaderboard() {
            document.getElementById('roleGroupFilter').addEventListener('change', (e) => {
                loadRoleLeaderboard(e.target.value);
            });
        }

        async function loadRoleLeaderboard(roleGroup) {
            const section = document.getElementById('roleLeaderboard');
            if (!roleGroup) {
                section.innerHTML = '<div class="text-center text-muted">Select a role to see player rankings by PPS</div>';
                return;
            }
            
            section.innerHTML = '<div class="text-center text-muted">Loading...</div>';

            const { data, error } = await HLL.supabase
                .from('role_leaderboard')
                .select('*')
                .eq('role_group', roleGroup)
                .order('avg_pps', { ascending: false });

            if (error) {
                section.innerHTML = `<div class="text-center text-muted">Error: ${error.message}</div>`;
                return;
            }

            if (!data || data.length === 0) {
                section.innerHTML = '<div class="text-center text-muted">No data for this role yet. Import matches with lineup data to populate.</div>';
                return;
            }

            // Choose which columns to emphasize based on role
            const isDefence = roleGroup === 'Defence' || roleGroup === 'Defence SL';
            const isSupport = roleGroup === 'Spotter' || roleGroup === 'Commander';
            const isTank = roleGroup === 'Tank Crew';

            section.innerHTML = `
                <table class="data-table" style="font-size: 0.85rem;">
                    <thead><tr>
                        <th>#</th>
                        <th>Player</th>
                        <th>Matches</th>
                        <th>Avg PPS</th>
                        <th>Best PPS</th>
                        <th>Avg K</th>
                        <th>Avg D</th>
                        <th>Avg K/D</th>
                        <th>Avg CE</th>
                        ${isDefence ? '<th style="color: #4ade80">Avg Def</th>' : '<th>Avg Def</th>'}
                        <th>Avg Off</th>
                        ${isSupport ? '<th style="color: #4ade80">Avg Sup</th>' : '<th>Avg Sup</th>'}
                    </tr></thead>
                    <tbody>
                        ${data.map((p, i) => `<tr>
                            <td>${i + 1}</td>
                            <td>${p.player_name}</td>
                            <td>${p.matches_in_role}</td>
                            <td><strong>${p.avg_pps}</strong></td>
                            <td>${p.best_pps}</td>
                            <td>${p.avg_kills}</td>
                            <td>${p.avg_deaths}</td>
                            <td>${p.avg_kd}</td>
                            <td>${p.avg_ce}</td>
                            <td>${p.avg_def}</td>
                            <td>${p.avg_off}</td>
                            <td>${p.avg_sup}</td>
                        </tr>`).join('')}
                    </tbody>
                </table>
                <p style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 8px;">
                    PPS = Performance Score based on combat, offense, defense, and support metrics weighted by K/D and KPM factors.
                    ${isDefence ? ' Defence players are expected to have higher defensive_pts.' : ''}
                    ${isSupport ? ' Support-oriented roles weight support_pts more heavily.' : ''}
                </p>`;
        }

        // ============================================================================
        // TAB SWITCHING
        // ============================================================================
        function switchStatsTab(tab) {
            document.getElementById('tab-players').style.display = tab === 'players' ? 'block' : 'none';
            document.getElementById('tab-compare').style.display = tab === 'compare' ? 'block' : 'none';
            
            document.getElementById('tab-btn-players').style.color = tab === 'players' ? 'var(--accent-orange)' : 'var(--text-secondary)';
            document.getElementById('tab-btn-players').style.borderBottomColor = tab === 'players' ? 'var(--accent-orange)' : 'transparent';
            document.getElementById('tab-btn-compare').style.color = tab === 'compare' ? 'var(--accent-orange)' : 'var(--text-secondary)';
            document.getElementById('tab-btn-compare').style.borderBottomColor = tab === 'compare' ? 'var(--accent-orange)' : 'transparent';

            if (tab === 'compare' && !window._compareLoaded) {
                window._compareLoaded = true;
                loadCompareTab();
            }
        }

        // ============================================================================
        // COMPARE TAB
        // ============================================================================
        async function loadCompareTab() {
            await Promise.all([
                loadMyTeamSummary(),
                loadDivisionDropdown(),
                loadH2HDropdown()
            ]);
        }

        // --- MY TEAM SUMMARY ---
        async function loadMyTeamSummary() {
            const section = document.getElementById('myTeamSummary');
            const myTeam = HLL.currentTeam || 'Circle';

            // Get my team's match stats
            const { data: matches } = await HLL.supabase
                .from('matches')
                .select('*')
                .eq('my_team', myTeam);

            // Get my team's player stats from match_details
            const { data: details } = await HLL.supabase
                .from('match_details')
                .select('kills, deaths, combat_eff')
                .eq('team', 'Friendly');

            if (!matches || matches.length === 0) {
                section.innerHTML = '<div class="text-center text-muted">No matches found</div>';
                return;
            }

            const totalMatches = matches.length;
            const wins = matches.filter(m => m.result === 'W').length;
            const losses = matches.filter(m => m.result === 'L').length;
            const draws = matches.filter(m => m.result === 'D').length;
            const winRate = totalMatches > 0 ? Math.round(wins / totalMatches * 100) : 0;
            const ptsFor = matches.reduce((s, m) => s + (m.my_score || 0), 0);
            const ptsAgainst = matches.reduce((s, m) => s + (m.enemy_score || 0), 0);

            const totalKills = (details || []).reduce((s, d) => s + (d.kills || 0), 0);
            const totalDeaths = (details || []).reduce((s, d) => s + (d.deaths || 0), 0);
            const avgKillsPerMatch = totalMatches > 0 ? (totalKills / totalMatches).toFixed(0) : '-';
            const avgDeathsPerMatch = totalMatches > 0 ? (totalDeaths / totalMatches).toFixed(0) : '-';
            const teamKD = totalDeaths > 0 ? (totalKills / totalDeaths).toFixed(2) : '-';

            // Get my divisions
            const { data: myDivs } = await HLL.supabase
                .from('my_team_divisions')
                .select('division_id')
                .eq('team_name', myTeam);
            let divNames = [];
            if (myDivs && myDivs.length > 0) {
                const { data: divData } = await HLL.supabase
                    .from('divisions')
                    .select('name')
                    .in('id', myDivs.map(d => d.division_id));
                divNames = (divData || []).map(d => d.name);
            }

            section.innerHTML = `
                <div style="margin-bottom: 12px;">
                    <span style="font-size: 1.2rem; font-weight: 700;">${myTeam}</span>
                    ${divNames.length > 0 ? '<span style="margin-left: 8px;">' + divNames.map(n => `<span style="padding: 2px 8px; border-radius: 3px; font-size: 0.75rem; background: rgba(255,152,0,0.15); color: #ff9800;">${n}</span>`).join(' ') + '</span>' : ''}
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px;">
                    <div class="stat-box"><span class="stat-value">${totalMatches}</span><span class="stat-label">Matches</span></div>
                    <div class="stat-box"><span class="stat-value" style="color: var(--accent-green)">${wins}</span><span class="stat-label">Wins</span></div>
                    <div class="stat-box"><span class="stat-value" style="color: var(--accent-red)">${losses}</span><span class="stat-label">Losses</span></div>
                    <div class="stat-box"><span class="stat-value">${winRate}%</span><span class="stat-label">Win Rate</span></div>
                    <div class="stat-box"><span class="stat-value">${ptsFor}-${ptsAgainst}</span><span class="stat-label">Score F/A</span></div>
                    <div class="stat-box"><span class="stat-value" style="color: ${parseFloat(teamKD) >= 1 ? 'var(--accent-green)' : 'var(--accent-red)'}">${teamKD}</span><span class="stat-label">Team K/D</span></div>
                    <div class="stat-box"><span class="stat-value">${avgKillsPerMatch}</span><span class="stat-label">Avg Kills/Match</span></div>
                    <div class="stat-box"><span class="stat-value">${avgDeathsPerMatch}</span><span class="stat-label">Avg Deaths/Match</span></div>
                </div>`;
        }

        // --- DIVISION RANKINGS ---
        async function loadDivisionDropdown() {
            const { data: divs } = await HLL.supabase
                .from('divisions')
                .select('*')
                .order('sort_order', { ascending: true });
            
            const select = document.getElementById('divisionFilter');
            (divs || []).forEach(d => {
                const opt = document.createElement('option');
                opt.value = d.id;
                opt.textContent = d.name;
                select.appendChild(opt);
            });
            select.addEventListener('change', () => loadDivisionRankings(select.value));
        }

        async function loadDivisionRankings(divisionId) {
            const section = document.getElementById('divisionRankings');
            if (!divisionId) {
                section.innerHTML = '<div class="text-center text-muted">Select a division to see rankings</div>';
                return;
            }

            section.innerHTML = '<div class="text-center text-muted">Loading...</div>';

            // Get division name
            const { data: divData } = await HLL.supabase
                .from('divisions')
                .select('name')
                .eq('id', divisionId)
                .single();
            const divName = divData?.name || '';

            // Get all enemy teams in this division
            const { data: teamLinks } = await HLL.supabase
                .from('enemy_team_divisions')
                .select('team_tag')
                .eq('division_id', divisionId);
            const enemyTags = (teamLinks || []).map(t => t.team_tag);

            // Check if my team is in this division
            const myTeam = HLL.currentTeam || 'Circle';
            const { data: myInDiv } = await HLL.supabase
                .from('my_team_divisions')
                .select('id')
                .eq('team_name', myTeam)
                .eq('division_id', divisionId);
            const myTeamInDiv = myInDiv && myInDiv.length > 0;

            // Get ALL matches of this division type (filtered by match_type)
            const { data: divMatches } = await HLL.supabase
                .from('matches')
                .select('*')
                .eq('match_type', divName);

            // Build rankings array
            const rankings = [];

            // Calculate stats per enemy team from division matches only
            for (const tag of enemyTags) {
                const teamMatches = (divMatches || []).filter(m => m.enemy_team === tag);
                if (teamMatches.length === 0) {
                    rankings.push({ tag, name: tag, matches: 0, wins: 0, losses: 0, winRate: 0, ptsFor: 0, ptsAgainst: 0, isMyTeam: false });
                    continue;
                }
                // From our perspective: our W = their L, our L = their W
                const theirWins = teamMatches.filter(m => m.result === 'L').length;
                const theirLosses = teamMatches.filter(m => m.result === 'W').length;
                rankings.push({
                    tag,
                    name: tag,
                    matches: teamMatches.length,
                    wins: theirWins,
                    losses: theirLosses,
                    winRate: teamMatches.length > 0 ? Math.round(theirWins / teamMatches.length * 100) : 0,
                    ptsFor: teamMatches.reduce((s, m) => s + (m.enemy_score || 0), 0),
                    ptsAgainst: teamMatches.reduce((s, m) => s + (m.my_score || 0), 0),
                    isMyTeam: false
                });
            }

            // Get my team stats (only matches of this division type)
            const myMatches = (divMatches || []).filter(m => m.my_team === myTeam);

            // Add my team if in this division
            if (myTeamInDiv && myMatches.length > 0) {
                const mw = myMatches.filter(m => m.result === 'W').length;
                const ml = myMatches.filter(m => m.result === 'L').length;
                rankings.push({
                    tag: myTeam,
                    name: myTeam,
                    matches: myMatches.length,
                    wins: mw,
                    losses: ml,
                    winRate: myMatches.length > 0 ? Math.round(mw / myMatches.length * 100) : 0,
                    ptsFor: myMatches.reduce((s, m) => s + (m.my_score || 0), 0),
                    ptsAgainst: myMatches.reduce((s, m) => s + (m.enemy_score || 0), 0),
                    isMyTeam: true
                });
            }

            // Sort by win rate desc, then wins desc
            rankings.sort((a, b) => b.winRate - a.winRate || b.wins - a.wins);

            if (rankings.length === 0) {
                section.innerHTML = '<div class="text-center text-muted">No teams found in this division</div>';
                return;
            }

            section.innerHTML = `
                <table class="data-table">
                    <thead><tr>
                        <th>#</th><th>Team</th><th>Matches</th><th>W</th><th>L</th><th>Win Rate</th><th>Pts F/A</th>
                    </tr></thead>
                    <tbody>
                        ${rankings.map((t, i) => `
                            <tr style="${t.isMyTeam ? 'background: rgba(255,152,0,0.1); font-weight: 600;' : ''}">
                                <td>${i + 1}</td>
                                <td>${t.isMyTeam ? '‚≠ê ' : ''}[${t.tag}] ${t.name !== t.tag ? t.name : ''}</td>
                                <td>${t.matches}</td>
                                <td style="color: var(--accent-green)">${t.wins}</td>
                                <td style="color: var(--accent-red)">${t.losses}</td>
                                <td><strong>${t.winRate}%</strong></td>
                                <td>${t.ptsFor}-${t.ptsAgainst}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>`;
        }

        // --- HEAD TO HEAD ---
        async function loadH2HDropdown() {
            const { data: teams } = await HLL.supabase
                .from('enemy_teams')
                .select('tag, name')
                .order('tag');
            
            const select = document.getElementById('h2hTeamSelect');
            (teams || []).forEach(t => {
                const opt = document.createElement('option');
                opt.value = t.tag;
                opt.textContent = `[${t.tag}] ${t.name || ''}`;
                select.appendChild(opt);
            });
            select.addEventListener('change', () => loadHeadToHead(select.value));
        }

        async function loadHeadToHead(enemyTag) {
            const section = document.getElementById('headToHead');
            const playerSection = document.getElementById('playerCompareSection');
            if (!enemyTag) {
                section.innerHTML = '<div class="text-center text-muted">Select an enemy team for head-to-head comparison</div>';
                playerSection.style.display = 'none';
                return;
            }

            section.innerHTML = '<div class="text-center text-muted">Loading...</div>';
            const myTeam = HLL.currentTeam || 'Circle';

            // Get matches against this team
            const { data: matches } = await HLL.supabase
                .from('matches')
                .select('*')
                .eq('enemy_team', enemyTag);

            if (!matches || matches.length === 0) {
                section.innerHTML = '<div class="text-center text-muted">No matches found against this team</div>';
                playerSection.style.display = 'none';
                return;
            }

            const matchIds = matches.map(m => m.match_id);

            // Get all match_details for these matches
            const { data: details } = await HLL.supabase
                .from('match_details')
                .select('*')
                .in('match_id', matchIds);

            const friendly = (details || []).filter(d => d.team === 'Friendly');
            const enemy = (details || []).filter(d => d.team === 'Enemy');

            const myKills = friendly.reduce((s, d) => s + (d.kills || 0), 0);
            const myDeaths = friendly.reduce((s, d) => s + (d.deaths || 0), 0);
            const theirKills = enemy.reduce((s, d) => s + (d.kills || 0), 0);
            const theirDeaths = enemy.reduce((s, d) => s + (d.deaths || 0), 0);

            const wins = matches.filter(m => m.result === 'W').length;
            const losses = matches.filter(m => m.result === 'L').length;
            const myKD = myDeaths > 0 ? (myKills / myDeaths).toFixed(2) : '-';
            const theirKD = theirDeaths > 0 ? (theirKills / theirDeaths).toFixed(2) : '-';
            const myAvgKills = matches.length > 0 ? (myKills / matches.length).toFixed(0) : '-';
            const theirAvgKills = matches.length > 0 ? (theirKills / matches.length).toFixed(0) : '-';

            const betterKD = parseFloat(myKD) > parseFloat(theirKD);

            section.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; align-items: start;">
                    <!-- My Team -->
                    <div style="text-align: center;">
                        <div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 12px; color: var(--accent-orange);">${myTeam}</div>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <div class="stat-box"><span class="stat-value" style="color: var(--accent-green)">${wins}</span><span class="stat-label">Wins</span></div>
                            <div class="stat-box"><span class="stat-value">${myKills}</span><span class="stat-label">Total Kills</span></div>
                            <div class="stat-box"><span class="stat-value">${myDeaths}</span><span class="stat-label">Total Deaths</span></div>
                            <div class="stat-box"><span class="stat-value" style="color: ${betterKD ? 'var(--accent-green)' : 'var(--accent-red)'}">${myKD}</span><span class="stat-label">K/D</span></div>
                            <div class="stat-box"><span class="stat-value">${myAvgKills}</span><span class="stat-label">Avg Kills/Match</span></div>
                        </div>
                    </div>
                    <!-- VS -->
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding-top: 40px;">
                        <div style="font-size: 1.5rem; font-weight: 700; color: var(--text-secondary);">VS</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px;">${matches.length} matches</div>
                    </div>
                    <!-- Enemy Team -->
                    <div style="text-align: center;">
                        <div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 12px; color: var(--text-primary);">[${enemyTag}]</div>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <div class="stat-box"><span class="stat-value" style="color: var(--accent-green)">${losses}</span><span class="stat-label">Wins</span></div>
                            <div class="stat-box"><span class="stat-value">${theirKills}</span><span class="stat-label">Total Kills</span></div>
                            <div class="stat-box"><span class="stat-value">${theirDeaths}</span><span class="stat-label">Total Deaths</span></div>
                            <div class="stat-box"><span class="stat-value" style="color: ${!betterKD ? 'var(--accent-green)' : 'var(--accent-red)'}">${theirKD}</span><span class="stat-label">K/D</span></div>
                            <div class="stat-box"><span class="stat-value">${theirAvgKills}</span><span class="stat-label">Avg Kills/Match</span></div>
                        </div>
                    </div>
                </div>`;

            // Load player comparison
            await loadPlayerComparison(matchIds, enemyTag);
        }

        // --- PLAYER COMPARISON ---
        async function loadPlayerComparison(matchIds, enemyTag) {
            const section = document.getElementById('playerCompareSection');
            const body = document.getElementById('playerCompare');
            section.style.display = 'block';
            body.innerHTML = '<div class="text-center text-muted">Loading...</div>';

            // Get friendly player stats for these matches
            const { data: friendlyDetails } = await HLL.supabase
                .from('match_details')
                .select('steam_id, player_name, kills, deaths')
                .in('match_id', matchIds)
                .eq('team', 'Friendly');

            // Get enemy player stats
            const { data: enemyDetails } = await HLL.supabase
                .from('match_details')
                .select('steam_id, player_name, kills, deaths')
                .in('match_id', matchIds)
                .eq('team', 'Enemy');

            // Aggregate by player
            function aggregatePlayers(details) {
                const map = {};
                (details || []).forEach(d => {
                    const key = d.steam_id || d.player_name;
                    if (!map[key]) map[key] = { name: d.player_name, kills: 0, deaths: 0, matches: 0 };
                    map[key].kills += d.kills || 0;
                    map[key].deaths += d.deaths || 0;
                    map[key].matches++;
                });
                return Object.values(map)
                    .map(p => ({ ...p, avgKills: (p.kills / p.matches).toFixed(1), kd: p.deaths > 0 ? (p.kills / p.deaths).toFixed(2) : '-' }))
                    .sort((a, b) => parseFloat(b.avgKills) - parseFloat(a.avgKills))
                    .slice(0, 10);
            }

            const myTop = aggregatePlayers(friendlyDetails);
            const theirTop = aggregatePlayers(enemyDetails);
            const maxRows = Math.max(myTop.length, theirTop.length);

            body.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                    <div>
                        <h4 style="text-align: center; margin-bottom: 8px; color: var(--accent-orange); font-size: 0.9rem;">Our Top Players</h4>
                        <table class="data-table" style="font-size: 0.85rem;">
                            <thead><tr><th>#</th><th>Name</th><th>Avg K</th><th>K/D</th></tr></thead>
                            <tbody>
                                ${myTop.map((p, i) => `<tr><td>${i+1}</td><td>${p.name}</td><td>${p.avgKills}</td><td>${p.kd}</td></tr>`).join('')}
                            </tbody>
                        </table>
                    </div>
                    <div>
                        <h4 style="text-align: center; margin-bottom: 8px; font-size: 0.9rem;">Their Top Players</h4>
                        <table class="data-table" style="font-size: 0.85rem;">
                            <thead><tr><th>#</th><th>Name</th><th>Avg K</th><th>K/D</th></tr></thead>
                            <tbody>
                                ${theirTop.map((p, i) => `<tr><td>${i+1}</td><td>${p.name}</td><td>${p.avgKills}</td><td>${p.kd}</td></tr>`).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>`;
        }

        init();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - HLL Tool v0.3.21</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        .import-zone {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .import-zone:hover, .import-zone.drag-over {
            border-color: var(--accent-orange);
            background: rgba(245, 166, 35, 0.1);
        }
        
        .import-zone input {
            display: none;
        }
        
        .import-preview {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 12px;
            margin-top: 16px;
            font-family: monospace;
            font-size: 11px;
            max-height: 200px;
            overflow: auto;
        }
        
        .admin-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 16px;
        }
        
        .action-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
        }
        
        .action-card h3 {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav-bar">
        <a href="../index.html" class="nav-logo">HLL Tool</a>
        <div class="nav-links">
            <a href="../index.html" class="nav-link">Home</a>
            <a href="lineup.html" class="nav-link">Lineups</a>
            <a href="roster.html" class="nav-link">Roster</a>
            <a href="stats.html" class="nav-link">Stats</a>
            <a href="matches.html" class="nav-link">Matches</a>
            <a href="admin.html" class="nav-link active">Admin</a>
        </div>
        <div class="nav-spacer"></div>
        <div class="nav-status">
            <span class="status-dot"></span>
            <span>Connecting...</span>
        </div>
    </nav>

    <div class="app-container">
        <!-- Header -->
        <div class="page-header">
            <h1 class="page-title">Admin</h1>
            <span class="version-badge">v0.3.21</span>
        </div>

        <div class="admin-grid">
            <!-- Add Player -->
            <div class="action-card">
                <h3>üë§ Add Player</h3>
                <div class="form-group">
                    <label class="form-label">Steam ID <span style="color: #8b949e; font-weight: 400;">(optional)</span></label>
                    <input type="text" class="form-input" id="newSteamId" placeholder="76561198... or leave blank">
                </div>
                <div class="form-group">
                    <label class="form-label">Player Name</label>
                    <input type="text" class="form-input" id="newPlayerName" placeholder="Player name">
                </div>
                <div class="form-group">
                    <label class="form-label">Team</label>
                    <select class="form-select" id="newPlayerTeam">
                        <option value="Circle">Circle</option>
                        <option value="DKB">DKB</option>
                        <option value="Merc">Merc</option>
                    </select>
                </div>
                <button class="btn btn-primary" onclick="addPlayer()">Add Player</button>
            </div>

            <!-- Bulk Import Players -->
            <div class="action-card">
                <h3>üì• Bulk Import Players</h3>
                <p class="text-muted mb-md">Import players from CSV. Format: steam_id, name, team</p>
                <div class="import-zone" id="playerImportZone">
                    <div>üìÑ Drop CSV file here or click to upload</div>
                    <input type="file" id="playerFileInput" accept=".csv">
                </div>
                <div class="import-preview hidden" id="playerImportPreview"></div>
                <button class="btn btn-primary mt-md hidden" id="confirmPlayerImport" onclick="confirmPlayerImport()">
                    Import Players
                </button>
            </div>

            <!-- Import Match -->
            <div class="action-card">
                <h3>üéÆ Import Match</h3>
                <p class="text-muted mb-md">Paste match data from helo-system.de</p>
                
                <div class="form-group">
                    <label class="form-label">Lineup Sheet</label>
                    <select class="form-select" id="matchLineupSelect">
                        <option value="1">Lineup 1</option>
                        <option value="2">Lineup 2</option>
                        <option value="3">Lineup 3</option>
                        <option value="4">Lineup 4</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Team Page Data</label>
                    <textarea class="form-input" id="teamPasteData" rows="4" placeholder="Paste team page data here..."></textarea>
                </div>
                
                <div class="form-group">
                    <label class="form-label">CSV File (from helo-system.de)</label>
                    <input type="file" class="form-input" id="csvFileInput" accept=".csv,.txt" style="padding: 8px;">
                </div>
                
                <button class="btn btn-primary" onclick="previewMatchImport()">Preview Import</button>
            </div>

            <!-- Database Tools -->
            <div class="action-card">
                <h3>üîß Database Tools</h3>
                
                <div class="mb-md">
                    <button class="btn btn-secondary" onclick="recalculateStats()">
                        üìä Recalculate All Stats
                    </button>
                    <p class="text-muted mt-sm" style="font-size: 11px;">
                        Recalculates all player statistics from match history.
                    </p>
                </div>
                
                <div class="mb-md">
                    <button class="btn btn-secondary" onclick="exportDatabase()">
                        üíæ Export All Data
                    </button>
                    <p class="text-muted mt-sm" style="font-size: 11px;">
                        Downloads all data as JSON backup.
                    </p>
                </div>
                
                <div>
                    <button class="btn btn-danger" onclick="clearAllLineups()">
                        üóëÔ∏è Clear All Lineups
                    </button>
                    <p class="text-muted mt-sm" style="font-size: 11px;">
                        Removes all current lineup assignments.
                    </p>
                </div>
            </div>
        </div>

        <!-- Import Preview Modal -->
        <div class="card mt-lg hidden" id="matchPreviewCard">
            <div class="card-header">
                <span class="card-title">Match Import Preview</span>
                <button class="btn btn-sm btn-secondary" onclick="cancelMatchImport()">Cancel</button>
            </div>
            <div class="card-body" id="matchPreviewBody">
                <!-- Populated by JS -->
            </div>
            <div style="padding: 16px; border-top: 1px solid var(--border-color); display: flex; gap: 8px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="cancelMatchImport()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmMatchImport()">Confirm Import</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay hidden" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading...</div>
    </div>

    <script src="../js/hll.js"></script>
    <script>
        // ============================================================================
        // STATE
        // ============================================================================
        
        let pendingPlayerImport = [];
        let pendingMatchImport = null;
        
        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        async function init() {
            await HLL.init();
            setupFileUpload();
        }
        
        function setupFileUpload() {
            const zone = document.getElementById('playerImportZone');
            const input = document.getElementById('playerFileInput');
            
            zone.addEventListener('click', () => input.click());
            
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('drag-over');
            });
            
            zone.addEventListener('dragleave', () => {
                zone.classList.remove('drag-over');
            });
            
            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('drag-over');
                const file = e.dataTransfer.files[0];
                if (file) processPlayerCSV(file);
            });
            
            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) processPlayerCSV(file);
            });
        }
        
        // ============================================================================
        // ADD SINGLE PLAYER
        // ============================================================================
        
        async function addPlayer() {
            let steamId = document.getElementById('newSteamId').value.trim();
            const name = document.getElementById('newPlayerName').value.trim();
            const team = document.getElementById('newPlayerTeam').value;
            
            if (!name) {
                HLL.showAlert('Please enter a player name', 'error');
                return;
            }
            
            // Generate temp ID if no SteamID provided
            if (!steamId) {
                steamId = 'TEMP-' + Math.random().toString(36).substr(2, 8).toUpperCase();
            }
            
            HLL.showLoading('Adding player...');
            
            const success = await HLL.createPlayer({
                steam_id: steamId,
                name: name,
                team: team
            });
            
            HLL.hideLoading();
            
            if (success) {
                const tempNote = steamId.startsWith('TEMP-') ? ' (no SteamID ‚Äî will pair on match import)' : '';
                HLL.showAlert('Player added successfully' + tempNote, 'success');
                document.getElementById('newSteamId').value = '';
                document.getElementById('newPlayerName').value = '';
            } else {
                HLL.showAlert('Failed to add player (may already exist)', 'error');
            }
        }
        
        // ============================================================================
        // BULK PLAYER IMPORT
        // ============================================================================
        
        function processPlayerCSV(file) {
            const reader = new FileReader();
            
            reader.onload = (e) => {
                const text = e.target.result;
                const lines = text.split('\n').filter(l => l.trim());
                
                // Skip header if present
                const startIndex = lines[0].toLowerCase().includes('steam') ? 1 : 0;
                
                pendingPlayerImport = [];
                
                for (let i = startIndex; i < lines.length; i++) {
                    const parts = lines[i].split(',').map(p => p.trim().replace(/^"|"$/g, ''));
                    
                    if (parts.length >= 2) {
                        pendingPlayerImport.push({
                            steam_id: parts[0],
                            name: cleanPlayerName(parts[1]),
                            team: parts[2] || 'Merc'
                        });
                    }
                }
                
                // Show preview
                const preview = document.getElementById('playerImportPreview');
                preview.classList.remove('hidden');
                preview.innerHTML = `
                    <strong>${pendingPlayerImport.length} players found:</strong><br>
                    ${pendingPlayerImport.slice(0, 10).map(p => `${p.name} (${p.team})`).join('<br>')}
                    ${pendingPlayerImport.length > 10 ? `<br>... and ${pendingPlayerImport.length - 10} more` : ''}
                `;
                
                document.getElementById('confirmPlayerImport').classList.remove('hidden');
            };
            
            reader.readAsText(file);
        }
        
        function cleanPlayerName(name) {
            // Strip common clan tags
            return name
                .replace(/^‚óØ\s*\|\s*/i, '')
                .replace(/^„Äá\s*‰∏®\s*/i, '')
                .replace(/^\[DKB\]\s*/i, '')
                .replace(/^‚ìá\s*\|\s*/i, '')
                .replace(/^UKLL\s*\|\s*/i, '')
                .trim();
        }
        
        async function confirmPlayerImport() {
            if (pendingPlayerImport.length === 0) return;
            
            HLL.showLoading(`Importing ${pendingPlayerImport.length} players...`);
            
            try {
                const { error } = await HLL.supabase
                    .from('players')
                    .upsert(pendingPlayerImport, { 
                        onConflict: 'steam_id',
                        ignoreDuplicates: false 
                    });
                
                if (error) throw error;
                
                HLL.hideLoading();
                HLL.showAlert(`Imported ${pendingPlayerImport.length} players`, 'success');
                
                // Reset
                pendingPlayerImport = [];
                document.getElementById('playerImportPreview').classList.add('hidden');
                document.getElementById('confirmPlayerImport').classList.add('hidden');
                document.getElementById('playerFileInput').value = '';
                
            } catch (err) {
                console.error('Import error:', err);
                HLL.hideLoading();
                HLL.showAlert('Import failed: ' + err.message, 'error');
            }
        }
        
        // ============================================================================
        // MATCH IMPORT (placeholder - full implementation would mirror VBA logic)
        // ============================================================================
        
        async function previewMatchImport() {
            const teamData = document.getElementById('teamPasteData').value.trim();
            const csvFileInput = document.getElementById('csvFileInput');
            
            if (!teamData) {
                HLL.showAlert('Please paste team page data', 'error');
                return;
            }
            
            // --- VALIDATE TEAM_PASTE DATA ---
            // Check for helo-system.de markers (case-insensitive, position-independent)
            const lowerTeamData = teamData.toLowerCase();
            const hasGameStats = lowerTeamData.includes('game statistics');
            const hasSearchPlayer = lowerTeamData.includes('search for a player');
            
            if (!hasGameStats || !hasSearchPlayer) {
                HLL.showAlert('This does not look like Team_Paste data from helo-system.de. Expected to find "Game statistics" and "Search for a player..." in the pasted text.', 'error');
                return;
            }
            
            // Extract summary for confirmation: faction (with count) and map
            const factionLineMatch = teamData.match(/(Allies|Axis)\s*\((\d+)\)/i);
            const pasteTeamFaction = factionLineMatch ? factionLineMatch[1] : 'Unknown faction';
            const pastePlayerCount = factionLineMatch ? factionLineMatch[2] : '?';
            
            // Detect map from paste for confirmation display
            const knownMaps = ['Carentan', 'Foy', 'Hill 400', 'Hurtgen Forest', 'H√ºrtgen Forest', 'Kursk', 
                'Omaha Beach', 'Purple Heart Lane', 'Remagen', 'Sainte-M√®re-√âglise', 'St. Marie Du Mont', 
                'Stalingrad', 'Utah Beach', 'Mortain', 'El Alamein', 'Driel', 'Kharkov'];
            let pasteMap = 'Unknown map';
            for (const map of knownMaps) {
                if (lowerTeamData.includes(map.toLowerCase())) { pasteMap = map; break; }
            }
            
            // Show confirmation popup
            const confirmMsg = `Team_Paste detected:\n\n` +
                `  Faction: ${pasteTeamFaction} (${pastePlayerCount} players)\n` +
                `  Map: ${pasteMap}\n\n` +
                `Is this the correct match data?`;
            
            if (!confirm(confirmMsg)) {
                return;
            }
            
            if (!csvFileInput.files || !csvFileInput.files[0]) {
                HLL.showAlert('Please upload a CSV file', 'error');
                return;
            }
            
            // Read CSV file
            const csvData = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = () => reject(new Error('Failed to read CSV file'));
                reader.readAsText(csvFileInput.files[0]);
            });
            
            HLL.showLoading('Processing match data...');
            
            try {
                // Step 1: Parse raw data
                const matchInfo = parseTeamData(teamData);
                const players = parseCSVData(csvData);
                const lineupNumber = document.getElementById('matchLineupSelect').value;
                
                if (players.length === 0) {
                    HLL.hideLoading();
                    HLL.showAlert('No players found in CSV data', 'error');
                    return;
                }
                
                // Step 2: Match players to roster (SteamID + Team_Paste names)
                await matchPlayersToRoster(players, matchInfo.friendlyNames);
                console.log(`[previewMatchImport] After roster match ‚Äî friendlyNames count: ${matchInfo.friendlyNames.length}`);
                
                // Step 3: Match players to lineup (sets roles, marks lineup players as friendly)
                const { lineupSlots } = await matchPlayersToLineup(players, lineupNumber, matchInfo);
                console.log(`[previewMatchImport] After lineup match ‚Äî friendly: ${players.filter(p=>p.isFriendly).length}, enemy: ${players.filter(p=>!p.isFriendly).length}`);
                
                // Step 4: Detect enemy team from [TAG] in enemy names
                matchInfo.enemyTeam = detectEnemyTeam(players);
                
                // Step 5: Determine result
                if (matchInfo.myScore != null && matchInfo.enemyScore != null) {
                    matchInfo.result = matchInfo.myScore > matchInfo.enemyScore ? 'W' :
                                       matchInfo.myScore < matchInfo.enemyScore ? 'L' : 'D';
                }
                
                // Step 6: Detect no-shows
                const noShows = detectNoShows(players, lineupSlots);
                
                // Step 7: Calculate MVP
                const mvp = calculateMVP(players);
                
                // Step 8: Detect TEMP players that can be paired with real SteamIDs
                const { data: rosterPlayers } = await HLL.supabase
                    .from('players')
                    .select('steam_id, name');
                const tempPlayers = (rosterPlayers || []).filter(p => p.steam_id.startsWith('TEMP-'));
                
                const pairings = [];
                if (tempPlayers.length > 0) {
                    const normalizeName = s => (s || '').replace(/[^a-z0-9]/gi, '').toLowerCase();
                    const friendlyPlayers = players.filter(p => p.isFriendly);
                    
                    for (const tp of tempPlayers) {
                        const match = friendlyPlayers.find(fp => 
                            normalizeName(fp.name) === normalizeName(tp.name) && fp.steamId
                        );
                        if (match) {
                            // Check the real SteamID isn't already in roster
                            const alreadyExists = (rosterPlayers || []).some(rp => rp.steam_id === match.steamId);
                            if (!alreadyExists) {
                                pairings.push({
                                    tempId: tp.steam_id,
                                    realSteamId: match.steamId,
                                    playerName: tp.name,
                                    approved: true // default checked
                                });
                            }
                        }
                    }
                }
                
                // Step 9: Validate
                const errors = [];
                const friendlyPlayers = players.filter(p => p.isFriendly);
                const enemyPlayers = players.filter(p => !p.isFriendly);
                
                if (!matchInfo.map) errors.push({ type: 'WARNING', msg: 'Could not detect map from team data' });
                if (!matchInfo.myFaction) errors.push({ type: 'WARNING', msg: 'Could not detect faction' });
                if (friendlyPlayers.length === 0) errors.push({ type: 'CRITICAL', msg: 'No friendly players detected' });
                if (!matchInfo.myScore && matchInfo.myScore !== 0) errors.push({ type: 'WARNING', msg: 'Could not detect score' });
                if (noShows.length > 0) errors.push({ type: 'INFO', msg: `${noShows.length} no-show(s) detected` });
                if (pairings.length > 0) errors.push({ type: 'INFO', msg: `${pairings.length} player(s) can be paired with SteamIDs` });
                
                const hasCritical = errors.some(e => e.type === 'CRITICAL');
                
                // Store for confirmMatchImport
                pendingMatchImport = {
                    matchInfo,
                    players,
                    lineupNumber,
                    noShows,
                    mvp,
                    friendlyPlayers,
                    enemyPlayers,
                    errors,
                    pairings
                };
                
                HLL.hideLoading();
                
                // Build preview HTML
                const previewCard = document.getElementById('matchPreviewCard');
                const previewBody = document.getElementById('matchPreviewBody');
                
                const resultColor = matchInfo.result === 'W' ? '#4ade80' : matchInfo.result === 'L' ? '#f87171' : '#fbbf24';
                const resultLabel = matchInfo.result === 'W' ? 'WIN' : matchInfo.result === 'L' ? 'LOSS' : matchInfo.result === 'D' ? 'DRAW' : '?';
                
                previewBody.innerHTML = `
                    ${errors.length > 0 ? `
                        <div style="background: ${hasCritical ? 'rgba(248,113,113,0.15)' : 'rgba(251,191,36,0.15)'}; border: 1px solid ${hasCritical ? '#f87171' : '#fbbf24'}; border-radius: 6px; padding: 10px; margin-bottom: 16px;">
                            <strong>${hasCritical ? '‚õî Critical Issues' : '‚ö†Ô∏è Warnings'}:</strong>
                            ${errors.map(e => `<div style="margin-top: 4px; font-size: 12px;">[${e.type}] ${e.msg}</div>`).join('')}
                        </div>
                    ` : ''}
                    
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 16px;">
                        <div class="stat-box">
                            <span class="stat-value">${matchInfo.map || '?'}</span>
                            <span class="stat-label">Map</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value" style="color: ${resultColor}">${matchInfo.myScore ?? '?'} - ${matchInfo.enemyScore ?? '?'}</span>
                            <span class="stat-label">Score (${resultLabel})</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value">${matchInfo.myFaction || '?'}</span>
                            <span class="stat-label">Faction</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value">${matchInfo.duration || '?'}</span>
                            <span class="stat-label">Duration</span>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 16px;">
                        <div class="stat-box">
                            <span class="stat-value">${matchInfo.date || '?'}</span>
                            <span class="stat-label">Date</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value">${matchInfo.enemyTeam || '?'}</span>
                            <span class="stat-label">Enemy Team</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value">${mvp ? mvp.name : '‚Äî'}</span>
                            <span class="stat-label">MVP (CE: ${mvp ? mvp.ce : '‚Äî'})</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value">${noShows.length}</span>
                            <span class="stat-label">No-Shows</span>
                        </div>
                    </div>
                    
                    <h4 style="margin-bottom: 8px;">Friendly Players: ${friendlyPlayers.length}</h4>
                    <div class="table-container" style="max-height: 250px; overflow: auto; margin-bottom: 16px;">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Role</th>
                                    <th>Kills</th>
                                    <th>Deaths</th>
                                    <th>K/D</th>
                                    <th>CE</th>
                                    <th>Support</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${friendlyPlayers.map(p => `
                                    <tr${mvp && p.steamId === mvp.steamId ? ' style="background: rgba(251,191,36,0.1);"' : ''}>
                                        <td>${p.name}${mvp && p.steamId === mvp.steamId ? ' ‚≠ê' : ''}</td>
                                        <td>${p.role || '‚Äî'}</td>
                                        <td>${p.kills}</td>
                                        <td>${p.deaths}</td>
                                        <td>${p.kd.toFixed(2)}</td>
                                        <td>${p.ce}</td>
                                        <td>${p.support}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    
                    <h4 style="margin-bottom: 8px;">Enemy Players: ${enemyPlayers.length}</h4>
                    <div class="table-container" style="max-height: 200px; overflow: auto; margin-bottom: 16px;">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Kills</th>
                                    <th>Deaths</th>
                                    <th>K/D</th>
                                    <th>CE</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${enemyPlayers.slice(0, 30).map(p => `
                                    <tr>
                                        <td>${p.name}</td>
                                        <td>${p.kills}</td>
                                        <td>${p.deaths}</td>
                                        <td>${p.kd.toFixed(2)}</td>
                                        <td>${p.ce}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    
                    ${noShows.length > 0 ? `
                        <h4 style="margin-bottom: 8px; color: #f87171;">No-Shows: ${noShows.length}</h4>
                        <div style="margin-bottom: 16px; font-size: 13px;">
                            ${noShows.map(ns => `<div style="padding: 2px 0;">‚Ä¢ ${ns.playerName || ns.steamId} (${ns.role})</div>`).join('')}
                        </div>
                    ` : ''}
                    
                    ${pairings.length > 0 ? `
                        <h4 style="margin-bottom: 8px; color: #f5a623;">üîó SteamID Pairing: ${pairings.length} player(s)</h4>
                        <div style="background: rgba(245,166,35,0.1); border: 1px solid #f5a623; border-radius: 6px; padding: 10px; margin-bottom: 16px; font-size: 13px;">
                            <div style="margin-bottom: 8px; color: #8b949e;">These players were added without a SteamID and can now be paired:</div>
                            ${pairings.map((p, i) => `
                                <div style="display: flex; align-items: center; gap: 8px; padding: 4px 0;">
                                    <input type="checkbox" id="pairing-${i}" checked style="accent-color: #f5a623;">
                                    <label for="pairing-${i}" style="flex: 1;">
                                        <strong>${p.playerName}</strong>
                                        <span style="color: #8b949e;"> ‚Üí ${p.realSteamId}</span>
                                    </label>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${hasCritical ? '<p style="color: #f87171; font-weight: bold;">‚õî Critical issues found. Import may produce incomplete data.</p>' : ''}
                `;
                
                previewCard.classList.remove('hidden');
                previewCard.scrollIntoView({ behavior: 'smooth' });
                
            } catch (err) {
                HLL.hideLoading();
                console.error('Preview error:', err);
                HLL.showAlert('Failed to process match data: ' + err.message, 'error');
            }
        }
        
        function parseTeamData(text) {
            // Full parsing of helo-system.de team page paste
            const info = {
                map: null,
                myScore: null,
                enemyScore: null,
                myFaction: null,
                enemyFaction: null,
                duration: null,
                date: null,
                enemyTeam: null,
                friendlyNames: []   // player names detected from team paste
            };

            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            const fullText = lines.join(' ');
            const lowerText = fullText.toLowerCase();

            // --- MAP DETECTION (case-insensitive, handle abbreviations) ---
            const mapAliases = {
                'carentan': 'Carentan', 'foy': 'Foy', 'hill 400': 'Hill 400',
                'hurtgen': 'Hurtgen Forest', 'h√ºrtgen': 'Hurtgen Forest',
                'kursk': 'Kursk', 'omaha': 'Omaha Beach', 'purple heart': 'Purple Heart Lane',
                'remagen': 'Remagen', 'sainte m√®re': 'SME', 'sainte-m√®re': 'SME',
                'sme': 'SME', 'st marie': 'SMDM', 'st. marie': 'SMDM', 'smdm': 'SMDM',
                'sainte-marie-du-mont': 'SMDM', 'stalingrad': 'Stalingrad',
                'utah': 'Utah Beach', 'mortain': 'Mortain', 'el alamein': 'El Alamein',
                'driel': 'Driel', 'kharkov': 'Kharkov'
            };
            // Sort by alias length descending so longer matches win (e.g. "hill 400" before "hill")
            const sortedAliases = Object.entries(mapAliases).sort((a, b) => b[0].length - a[0].length);
            for (const [alias, mapName] of sortedAliases) {
                if (lowerText.includes(alias)) { info.map = mapName; break; }
            }

            // --- DATE DETECTION ---
            // Try YYYY-MM-DD first, then DD/MM/YYYY, DD.MM.YYYY
            const datePatterns = [
                { re: /(\d{4}-\d{2}-\d{2})/, fmt: 'iso' },
                { re: /(\d{1,2})[\/.](\d{1,2})[\/.](\d{4})/, fmt: 'dmy4' },
                { re: /(\d{1,2})[\/.](\d{1,2})[\/.](\d{2})/, fmt: 'dmy2' }
            ];
            for (const { re, fmt } of datePatterns) {
                const m = fullText.match(re);
                if (m) {
                    if (fmt === 'iso') {
                        info.date = m[1];
                    } else {
                        const yr = fmt === 'dmy2' ? '20' + m[3] : m[3];
                        info.date = `${yr}-${m[2].padStart(2, '0')}-${m[1].padStart(2, '0')}`;
                    }
                    break;
                }
            }
            if (!info.date) info.date = new Date().toISOString().split('T')[0];

            // --- SCORE (X:Y or X-Y or X ‚Äì Y, single digits 0-5) ---
            // Normalize non-breaking spaces (U+00A0) that helo-system uses
            const normalizedText = fullText.replace(/\u00a0/g, ' ');
            const scoreMatch = normalizedText.match(/\b(\d)\s*[-‚Äì:]\s*(\d)\b/);
            if (scoreMatch) {
                info.myScore = parseInt(scoreMatch[1]);
                info.enemyScore = parseInt(scoreMatch[2]);
            }

            // --- FACTION ---
            // VBA ParseFaction requires both faction word AND parenthesis in same text
            // e.g. "Axis (49)" or "Allies (50)" ‚Äî this is the selected faction tab on helo-system
            // Simple "Allies" or "Axis" without parenthesis are just labels, not your faction
            for (const line of lines) {
                const lower = line.toLowerCase().replace(/\u00a0/g, ' ');
                if (lower.includes('(') && lower.includes(')')) {
                    if (lower.includes('allies')) {
                        info.myFaction = 'Allies';
                        info.enemyFaction = 'Axis';
                        break;
                    } else if (lower.includes('axis')) {
                        info.myFaction = 'Axis';
                        info.enemyFaction = 'Allies';
                        break;
                    }
                }
            }
            // Fallback: if no parenthesized faction found, try simple match
            if (!info.myFaction) {
                if (lowerText.includes('allies')) {
                    info.myFaction = 'Allies';
                    info.enemyFaction = 'Axis';
                } else if (lowerText.includes('axis')) {
                    info.myFaction = 'Axis';
                    info.enemyFaction = 'Allies';
                }
            }

            // --- DURATION (H:MM:SS or HH:MM:SS) ---
            const durMatch = fullText.match(/(\d{1,2}:\d{2}:\d{2})/);
            if (durMatch) info.duration = durMatch[1];

            // --- ENEMY TEAM NAME ---
            // Not detected here. Derived from enemy player clan tags after CSV parsing
            // (mirrors VBA DetectEnemyTeam which scans [TAG] in enemy player names)

            // --- FRIENDLY PLAYER NAMES ---
            // helo-system team page: rows with a numeric rank in first column, name in col C
            // Tab-separated when pasted from browser
            let debugTabLines = 0;
            let debugRankLines = 0;
            for (const line of lines) {
                const parts = line.split('\t');
                if (parts.length >= 2) {
                    debugTabLines++;
                    const rank = parts[0].trim();
                    if (/^\d{1,3}$/.test(rank)) {
                        debugRankLines++;
                        // Name is typically in col C (index 2), fallback to col B (index 1)
                        const name = (parts[2] || parts[1] || '').trim();
                        if (name && name.length > 1 && !/^\d+$/.test(name)) {
                            info.friendlyNames.push(name);
                        }
                    }
                }
            }
            console.log(`[parseTeamData] Total lines: ${lines.length}, Tab-split lines (‚â•2 parts): ${debugTabLines}, Rank lines: ${debugRankLines}, Names extracted: ${info.friendlyNames.length}`);
            if (info.friendlyNames.length > 0) {
                console.log(`[parseTeamData] First 5 names:`, info.friendlyNames.slice(0, 5));
            }
            if (info.friendlyNames.length === 0 && lines.length > 10) {
                console.warn(`[parseTeamData] ‚ö†Ô∏è No friendly names extracted! Sample lines:`);
                lines.slice(0, 5).forEach((l, i) => {
                    console.log(`  Line ${i}: "${l.substring(0, 80)}" | tab-split parts: ${l.split('\t').length}`);
                });
            }

            return info;
        }
        
        function parseCSVData(text) {
            const lines = text.split('\n').filter(l => l.trim());
            const players = [];
            
            if (lines.length < 2) return players;
            
            // Detect delimiter: tab or comma
            const headerLine = lines[0];
            const isTab = headerLine.includes('\t');
            
            // Skip header row (row 0)
            for (let i = 1; i < lines.length; i++) {
                // Use proper CSV parsing for comma-delimited (handles quoted JSON fields)
                const parts = isTab
                    ? lines[i].split('\t').map(p => p.trim().replace(/^"|"$/g, ''))
                    : parseCSVLine(lines[i]);
                
                if (parts.length < 5) continue;
                
                // Column mapping matches VBA Raw_Paste constants (RP_*)
                // Index: 0=SteamID, 1=Name, 2=Kills, 3=Deaths, 4=K/D,
                // 5=MaxStreak, 6=KPM, 7=DPM, 8=MaxDeath, 9=MaxTK, 10=DeathByTK,
                // 11=DeathByTKStreak(skip), 12=LongLife, 13=ShortLife,
                // 14=Nemesis(skip), 15=Victim(skip), 16=CE, 17=Support,
                // 18=Defensive, 19=Offensive
                players.push({
                    steamId:        parts[0] || '',
                    name:           (parts[1] || '').trim(),
                    kills:          parseInt(parts[2]) || 0,
                    deaths:         parseInt(parts[3]) || 0,
                    kd:             parseFloat(parts[4]) || 0,
                    maxKillStreak:  parseInt(parts[5]) || 0,
                    kpm:            parseFloat(parts[6]) || 0,
                    dpm:            parseFloat(parts[7]) || 0,
                    maxDeathStreak: parseInt(parts[8]) || 0,
                    maxTkStreak:    parseInt(parts[9]) || 0,
                    deathByTk:      parseInt(parts[10]) || 0,
                    longestLifeMin: parseFloat(parts[12]) || 0,
                    shortestLifeSec:parseInt(parts[13]) || 0,
                    ce:             parseInt(parts[16]) || 0,
                    support:        parseInt(parts[17]) || 0,
                    defensive:      parseInt(parts[18]) || 0,
                    offensive:      parseInt(parts[19]) || 0,
                    // These will be set by later processing steps
                    isFriendly:     false,
                    role:           '',
                    faction:        ''
                });
            }
            
            return players;
        }
        
        /**
         * Parse a CSV line handling quoted fields (e.g., JSON columns with commas).
         * Handles "" as escaped quotes within quoted fields.
         */
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const c = line[i];
                if (c === '"') {
                    if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
                        current += '"';
                        i++; // skip escaped quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (c === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += c;
                }
            }
            result.push(current.trim());
            
            return result;
        }
        
        // ============================================================================
        // MATCH PROCESSING (mirrors VBA: MatchPlayersToRoster, MatchPlayersToLineup,
        //                   DetectNoShows, CalculateMVP, DetectEnemyTeam)
        // ============================================================================
        
        /**
         * Cross-reference CSV players with Supabase roster + Team_Paste friendly names.
         * Sets isFriendly flag on each player.
         * Mirrors VBA v5.5.23 MatchPlayersToRoster (line 627):
         *   Check 1: SteamID exists in roster ‚Üí friendly
         *   Check 2: Name matches Team_Paste friendly names ‚Üí friendly
         *   Everyone else ‚Üí Enemy
         */
        async function matchPlayersToRoster(players, friendlyNames) {
            // Build roster SteamID set from Supabase
            const { data: rosterPlayers } = await HLL.supabase
                .from('players')
                .select('steam_id, name');
            
            const rosterSteamIds = new Set((rosterPlayers || []).map(p => p.steam_id));
            
            // Normalize friendly names from Team_Paste for fuzzy matching
            const normalizedFriendly = new Set(
                (friendlyNames || []).map(n => normalizeName(n))
            );
            
            // Debug logging
            console.log(`[matchPlayersToRoster] Roster SteamIDs in DB: ${rosterSteamIds.size}`);
            console.log(`[matchPlayersToRoster] Team_Paste friendly names: ${normalizedFriendly.size}`);
            if (normalizedFriendly.size > 0) {
                console.log(`[matchPlayersToRoster] First 5 friendly names:`, [...normalizedFriendly].slice(0, 5));
            }
            if (normalizedFriendly.size === 0) {
                console.warn(`[matchPlayersToRoster] ‚ö†Ô∏è NO friendly names from Team_Paste! Check parseTeamData.`);
            }
            
            let matchedBySteam = 0;
            let matchedByName = 0;
            
            for (const player of players) {
                // Check 1: SteamID exists in roster ‚Üí friendly
                if (rosterSteamIds.has(player.steamId)) {
                    player.isFriendly = true;
                    matchedBySteam++;
                }
                // Check 2: Name matches Team_Paste friendly names ‚Üí friendly
                else if (normalizedFriendly.has(normalizeName(player.name))) {
                    player.isFriendly = true;
                    matchedByName++;
                }
            }
            
            const totalFriendly = players.filter(p => p.isFriendly).length;
            const totalEnemy = players.filter(p => !p.isFriendly).length;
            console.log(`[matchPlayersToRoster] Matched: ${matchedBySteam} by SteamID, ${matchedByName} by name`);
            console.log(`[matchPlayersToRoster] Result: ${totalFriendly} friendly, ${totalEnemy} enemy`);
        }
        
        /**
         * Normalize name for comparison: strip non-alphanumeric, lowercase.
         * Mirrors VBA NormalizeName (line 661).
         */
        function normalizeName(name) {
            return (name || '').replace(/[^a-z0-9]/gi, '').toLowerCase();
        }
        
        /**
         * Get role assignments from the selected lineup in Supabase.
         * Sets role and faction on each player.
         * Also marks lineup players as friendly.
         * Mirrors VBA MatchPlayersToLineup (line 690).
         */
        async function matchPlayersToLineup(players, lineupNumber, matchInfo) {
            // Get lineup data from Supabase
            const { data: lineupSlots } = await HLL.supabase
                .from('lineups')
                .select('cell_position, steam_id, player_name, role')
                .eq('lineup_number', parseInt(lineupNumber));
            
            // Build lookup: steam_id ‚Üí role, and name ‚Üí role (fallback)
            const steamToRole = {};
            const nameToRole = {};
            const lineupSteamIds = new Set();
            const lineupNames = new Set();
            
            for (const slot of (lineupSlots || [])) {
                if (slot.steam_id) {
                    steamToRole[slot.steam_id] = slot.role || getRoleFromCellPosition(slot.cell_position);
                    lineupSteamIds.add(slot.steam_id);
                }
                if (slot.player_name) {
                    nameToRole[normalizeName(slot.player_name)] = slot.role || getRoleFromCellPosition(slot.cell_position);
                    lineupNames.add(normalizeName(slot.player_name));
                }
            }
            
            // Match players to lineup roles
            for (const player of players) {
                if (steamToRole[player.steamId]) {
                    player.isFriendly = true;
                    player.role = steamToRole[player.steamId];
                } else if (nameToRole[normalizeName(player.name)]) {
                    player.isFriendly = true;
                    player.role = nameToRole[normalizeName(player.name)];
                }
                
                // Set faction based on friendly/enemy
                player.faction = player.isFriendly
                    ? (matchInfo.myFaction || 'Allies')
                    : (matchInfo.enemyFaction || 'Axis');
            }
            
            return { lineupSteamIds, lineupNames, lineupSlots: lineupSlots || [] };
        }
        
        /**
         * Derive role from data-cell position.
         * Maps cell IDs like 'cmd-1', 't1-tc', 'nw-3' to role names.
         */
        function getRoleFromCellPosition(cellPos) {
            if (!cellPos) return 'Infantry';
            const pos = cellPos.toLowerCase();
            
            if (pos.startsWith('cmd'))  return 'Commander';
            if (pos.startsWith('art'))  return 'Artillery';
            if (pos.startsWith('str'))  return 'Streamer';
            if (pos.includes('-tc'))    return 'TC';
            if (pos.includes('-gun'))   return 'Gunner';
            if (pos.includes('-drv'))   return 'Driver';
            if (pos.includes('-spot')) return 'Spotter';
            if (pos.includes('-snip')) return 'Sniper';
            if (pos.startsWith('nn-') || pos.startsWith('nm-') || pos.startsWith('ns-')) return 'Defence';
            // Infantry sections: nw, def, mg, flx, se, inf
            return 'Infantry';
        }
        
        /**
         * Detect players in lineup but not in game data.
         * Returns array of no-show objects.
         * Mirrors VBA DetectNoShows (line 762).
         */
        function detectNoShows(players, lineupSlots) {
            const gameSteamIds = new Set(players.map(p => p.steamId));
            const gameNames = new Set(players.map(p => normalizeName(p.name)));
            const noShows = [];
            
            for (const slot of lineupSlots) {
                if (!slot.player_name && !slot.steam_id) continue;
                
                // Check if this lineup player appeared in the game
                const inGameBySteam = slot.steam_id && gameSteamIds.has(slot.steam_id);
                const inGameByName = slot.player_name && gameNames.has(normalizeName(slot.player_name));
                
                if (!inGameBySteam && !inGameByName) {
                    noShows.push({
                        steamId: slot.steam_id || '',
                        playerName: slot.player_name || '',
                        role: slot.role || getRoleFromCellPosition(slot.cell_position)
                    });
                }
            }
            
            return noShows;
        }
        
        /**
         * Find MVP: highest CE among friendly players, excluding Artillery.
         * Mirrors VBA CalculateMVP (line 789).
         */
        function calculateMVP(players) {
            let mvp = null;
            let maxCE = 0;
            
            for (const player of players) {
                if (player.isFriendly && player.ce > maxCE && player.role !== 'Artillery') {
                    maxCE = player.ce;
                    mvp = player;
                }
            }
            
            return mvp;
        }
        
        /**
         * Detect enemy team name from most common [TAG] in enemy player names.
         * Mirrors VBA DetectEnemyTeam (line 539).
         */
        function detectEnemyTeam(players) {
            const tagCounts = {};
            
            for (const player of players) {
                if (player.isFriendly) continue;
                
                const match = player.name.match(/\[([A-Za-z0-9]{2,10})\]/);
                if (match) {
                    const tag = match[1];
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                }
            }
            
            let maxTag = 'Unknown';
            let maxCount = 0;
            for (const [tag, count] of Object.entries(tagCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    maxTag = tag;
                }
            }
            
            return maxTag;
        }
        
        // ============================================================================
        // CONFIRM MATCH IMPORT
        // ============================================================================
        async function confirmMatchImport() {
            if (!pendingMatchImport) return;
            
            const { matchInfo, players, noShows, mvp, friendlyPlayers, pairings } = pendingMatchImport;
            
            HLL.showLoading('Importing match...');
            
            try {
                // --- PRE-STEP: Apply SteamID pairings for TEMP players ---
                if (pairings && pairings.length > 0) {
                    for (let i = 0; i < pairings.length; i++) {
                        const p = pairings[i];
                        const checkbox = document.getElementById(`pairing-${i}`);
                        if (checkbox && checkbox.checked) {
                            // Insert new row with real SteamID, copy data from temp
                            const { data: tempPlayer } = await HLL.supabase
                                .from('players')
                                .select('*')
                                .eq('steam_id', p.tempId)
                                .single();
                            
                            if (tempPlayer) {
                                // Create player with real SteamID
                                const newPlayer = { ...tempPlayer, steam_id: p.realSteamId };
                                delete newPlayer.created_at;
                                delete newPlayer.updated_at;
                                
                                const { error: insertErr } = await HLL.supabase
                                    .from('players')
                                    .insert(newPlayer);
                                
                                if (!insertErr) {
                                    // Delete temp entry
                                    await HLL.supabase
                                        .from('players')
                                        .delete()
                                        .eq('steam_id', p.tempId);
                                    
                                    console.log(`Paired ${p.playerName}: ${p.tempId} ‚Üí ${p.realSteamId}`);
                                } else {
                                    console.warn(`Failed to pair ${p.playerName}:`, insertErr);
                                }
                            }
                        }
                    }
                }
                
                // --- 0. AUTO-ADD NEW FRIENDLY PLAYERS TO ROSTER (must be before match insert for FK) ---
                await autoAddNewPlayers(friendlyPlayers, matchInfo);
                
                // Generate match ID (MTH-XXXXXX format, sequential)
                const matchId = await generateMatchId();
                
                // --- 1. INSERT MATCH (Match_Log equivalent) ---
                const { error: matchError } = await HLL.supabase
                    .from('matches')
                    .insert({
                        match_id: matchId,
                        match_date: matchInfo.date,
                        my_team: HLL.currentTeam || 'Circle',
                        enemy_team: matchInfo.enemyTeam || 'Unknown',
                        my_faction: matchInfo.myFaction || 'Allies',
                        enemy_faction: matchInfo.enemyFaction || 'Axis',
                        map: matchInfo.map || 'Unknown',
                        result: matchInfo.result || 'D',
                        my_score: matchInfo.myScore,
                        enemy_score: matchInfo.enemyScore,
                        duration: matchInfo.duration,
                        mvp_steam_id: mvp ? mvp.steamId : null,
                        mvp_name: mvp ? mvp.name : null
                    });
                if (matchError) throw matchError;
                
                // --- 2. INSERT MATCH_DETAILS (all players, all stats) ---
                const details = players.map(p => ({
                    match_id: matchId,
                    steam_id: p.steamId,
                    player_name: p.name,
                    faction: p.faction,
                    team: p.isFriendly ? 'Friendly' : 'Enemy',
                    role: p.role || null,
                    kills: p.kills,
                    deaths: p.deaths,
                    kd: p.kd,
                    max_kill_streak: p.maxKillStreak,
                    kpm: p.kpm,
                    dpm: p.dpm,
                    max_death_streak: p.maxDeathStreak,
                    max_tk_streak: p.maxTkStreak,
                    death_by_tk: p.deathByTk,
                    longest_life_min: p.longestLifeMin,
                    shortest_life_sec: p.shortestLifeSec,
                    combat_eff: p.ce,
                    support_pts: p.support,
                    defensive_pts: p.defensive,
                    offensive_pts: p.offensive
                }));
                
                const { error: detailsError } = await HLL.supabase
                    .from('match_details')
                    .insert(details);
                if (detailsError) throw detailsError;
                
                // --- 3. INSERT MATCH_LINEUPS (friendly players with roles) ---
                const lineupRows = friendlyPlayers
                    .filter(p => p.role)
                    .map(p => ({
                        match_id: matchId,
                        role: p.role,
                        player_name: p.name,
                        steam_id: p.steamId
                    }));
                
                if (lineupRows.length > 0) {
                    const { error: lineupError } = await HLL.supabase
                        .from('match_lineups')
                        .insert(lineupRows);
                    if (lineupError) throw lineupError;
                }
                
                // --- 4. INSERT NO_SHOWS ---
                if (noShows.length > 0) {
                    const noShowRows = noShows
                        .filter(ns => ns.steamId) // Need steam_id for FK
                        .map(ns => ({
                            match_id: matchId,
                            steam_id: ns.steamId,
                            player_name: ns.playerName,
                            match_date: matchInfo.date,
                            excused: false
                        }));
                    
                    if (noShowRows.length > 0) {
                        const { error: noShowError } = await HLL.supabase
                            .from('no_shows')
                            .insert(noShowRows);
                        if (noShowError) {
                            console.warn('No-show insert warning:', noShowError);
                            // Non-critical, don't block import
                        }
                    }
                }
                
                // --- 5. UPDATE PLAYER STATS (via DB function) ---
                try {
                    await HLL.supabase.rpc('update_player_stats_from_match', { p_match_id: matchId });
                } catch (rpcErr) {
                    console.warn('Player stats update warning:', rpcErr);
                    // Non-critical ‚Äî stats can be recalculated later
                }
                
                HLL.hideLoading();
                
                const resultText = matchInfo.result === 'W' ? 'WIN' : matchInfo.result === 'L' ? 'LOSS' : 'DRAW';
                HLL.showAlert(
                    `Match imported: ${matchId}\n` +
                    `${matchInfo.map} ‚Äî ${matchInfo.myScore}:${matchInfo.enemyScore} (${resultText})\n` +
                    `${friendlyPlayers.length} friendly, ${players.length - friendlyPlayers.length} enemy\n` +
                    `${noShows.length} no-show(s)` +
                    (mvp ? `\nMVP: ${mvp.name} (CE: ${mvp.ce})` : ''),
                    'success'
                );
                cancelMatchImport();
                
            } catch (err) {
                console.error('Match import error:', err);
                HLL.hideLoading();
                HLL.showAlert('Import failed: ' + err.message, 'error');
            }
        }
        
        /**
         * Generate sequential match ID (MTH-000001, MTH-000002, ...).
         * Mirrors VBA GenerateMatchID (line 867).
         */
        async function generateMatchId() {
            const { data, error } = await HLL.supabase
                .from('matches')
                .select('match_id')
                .order('match_id', { ascending: false })
                .limit(1);
            
            let num = 1;
            if (!error && data && data.length > 0) {
                const lastId = data[0].match_id; // e.g., "MTH-000005"
                const lastNum = parseInt(lastId.replace('MTH-', ''), 10);
                if (!isNaN(lastNum)) num = lastNum + 1;
            }
            
            return 'MTH-' + String(num).padStart(6, '0');
        }
        
        /**
         * Auto-add new friendly players to roster if not already present.
         * Mirrors VBA UpdateRosterStats new player logic (line 1064).
         */
        async function autoAddNewPlayers(friendlyPlayers, matchInfo) {
            if (!friendlyPlayers.length) return;
            
            // Get existing roster with names and previous_names
            const { data: existing } = await HLL.supabase
                .from('players')
                .select('steam_id, name, previous_names');
            
            const rosterMap = {};
            (existing || []).forEach(p => { rosterMap[p.steam_id] = p; });
            
            const newPlayers = [];
            const nameChanges = [];
            
            for (const p of friendlyPlayers) {
                if (!p.steamId) continue;
                
                const rosterPlayer = rosterMap[p.steamId];
                if (!rosterPlayer) {
                    // NEW PLAYER ‚Äî add to roster
                    newPlayers.push({
                        steam_id: p.steamId,
                        name: p.name,
                        team: HLL.currentTeam || 'Circle',
                        first_seen: matchInfo.date,
                        last_seen: matchInfo.date
                    });
                } else {
                    // EXISTING PLAYER ‚Äî check for name change
                    const oldName = (rosterPlayer.name || '').trim();
                    const newName = (p.name || '').trim();
                    const normalize = s => (s || '').replace(/[^a-z0-9]/gi, '').toLowerCase();
                    
                    if (normalize(oldName) !== normalize(newName) && newName.length > 0) {
                        // Name changed ‚Äî append old name to previous_names array
                        const prevNames = rosterPlayer.previous_names || [];
                        const prevLower = prevNames.map(n => normalize(n));
                        
                        // Only add old name if not already tracked
                        if (!prevLower.includes(normalize(oldName))) {
                            prevNames.push(oldName);
                        }
                        
                        nameChanges.push({
                            steamId: p.steamId,
                            newName: newName,
                            prevNames: prevNames
                        });
                    }
                }
            }
            
            // Insert new players
            if (newPlayers.length > 0) {
                const { error } = await HLL.supabase
                    .from('players')
                    .upsert(newPlayers, { onConflict: 'steam_id', ignoreDuplicates: true });
                
                if (error) console.warn('Auto-add players warning:', error);
                else console.log(`Auto-added ${newPlayers.length} new player(s) to roster`);
            }
            
            // Update name changes
            for (const nc of nameChanges) {
                const { error } = await HLL.supabase
                    .from('players')
                    .update({ name: nc.newName, previous_names: nc.prevNames })
                    .eq('steam_id', nc.steamId);
                
                if (error) console.warn(`Name change update failed for ${nc.steamId}:`, error);
                else console.log(`Name change: ${nc.prevNames[nc.prevNames.length - 1]} ‚Üí ${nc.newName}`);
            }
            
            if (nameChanges.length > 0) {
                console.log(`Tracked ${nameChanges.length} name change(s)`);
            }
        }
        
        function cancelMatchImport() {
            pendingMatchImport = null;
            document.getElementById('matchPreviewCard').classList.add('hidden');
            document.getElementById('teamPasteData').value = '';
            document.getElementById('csvFileInput').value = '';
        }
        
        // ============================================================================
        // DATABASE TOOLS
        // ============================================================================
        
        async function recalculateStats() {
            if (!HLL.confirm('This will recalculate all player statistics from match history. Continue?')) {
                return;
            }
            
            HLL.showLoading('Recalculating stats...');
            
            // This would call a Supabase function or do client-side recalculation
            // For now, just show a message
            
            setTimeout(() => {
                HLL.hideLoading();
                HLL.showAlert('Stats recalculation not yet implemented', 'warning');
            }, 1000);
        }
        
        async function exportDatabase() {
            HLL.showLoading('Exporting data...');
            
            try {
                const { data: players } = await HLL.supabase.from('players').select('*');
                const { data: matches } = await HLL.supabase.from('matches').select('*');
                const { data: details } = await HLL.supabase.from('match_details').select('*');
                
                const exportData = {
                    exported_at: new Date().toISOString(),
                    version: HLL.version,
                    players,
                    matches,
                    match_details: details
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `HLL_Backup_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                HLL.hideLoading();
                HLL.showAlert('Database exported', 'success');
                
            } catch (err) {
                console.error('Export error:', err);
                HLL.hideLoading();
                HLL.showAlert('Export failed', 'error');
            }
        }
        
        async function clearAllLineups() {
            if (!HLL.confirm('This will remove ALL lineup assignments. This cannot be undone. Continue?')) {
                return;
            }
            
            HLL.showLoading('Clearing lineups...');
            
            try {
                const { error } = await HLL.supabase
                    .from('lineups')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000'); // Delete all
                
                if (error) throw error;
                
                HLL.hideLoading();
                HLL.showAlert('All lineups cleared', 'success');
                
            } catch (err) {
                console.error('Clear error:', err);
                HLL.hideLoading();
                HLL.showAlert('Failed to clear lineups', 'error');
            }
        }
        
        // Start
        init();
    </script>
</body>
</html>

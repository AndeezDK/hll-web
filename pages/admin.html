<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - HLL Tool v0.6.17</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        .import-zone {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .import-zone:hover, .import-zone.drag-over {
            border-color: var(--accent-orange);
            background: rgba(245, 166, 35, 0.1);
        }
        
        .import-zone input {
            display: none;
        }
        
        .import-preview {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 12px;
            margin-top: 16px;
            font-family: monospace;
            font-size: 11px;
            max-height: 200px;
            overflow: auto;
        }
        
        .admin-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 16px;
        }
        
        .action-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
        }
        
        .action-card h3 {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav-bar">
        <a href="../index.html" class="nav-logo">HLL Tool</a>
        <div class="nav-links">
            <a href="../index.html" class="nav-link">Home</a>
            <a href="lineup.html" class="nav-link">Lineups</a>
            <a href="roster.html" class="nav-link">Roster</a>
            <a href="stats.html" class="nav-link">Stats</a>
            <a href="matches.html" class="nav-link">Matches</a>
            <a href="enemies.html" class="nav-link">Enemy Intel</a>
            <a href="admin.html" class="nav-link active">Admin</a>
        </div>
        <div class="nav-spacer"></div>
        <div class="nav-status">
            <span class="status-dot"></span>
            <span>Connecting...</span>
        </div>
    </nav>

    <div class="app-container">
        <!-- Header -->
        <div class="page-header">
            <h1 class="page-title">Admin</h1>
            <span class="version-badge">v0.6.17</span>
        </div>

        <div class="admin-grid">
            <!-- Add Player -->
            <div class="action-card">
                <h3>üë§ Add Player</h3>
                <div class="form-group">
                    <label class="form-label">Steam ID <span style="color: #8b949e; font-weight: 400;">(optional)</span></label>
                    <input type="text" class="form-input" id="newSteamId" placeholder="76561198... or leave blank">
                </div>
                <div class="form-group">
                    <label class="form-label">Player Name</label>
                    <input type="text" class="form-input" id="newPlayerName" placeholder="Player name">
                </div>
                <div class="form-group">
                    <label class="form-label">Team</label>
                    <select class="form-select" id="newPlayerTeam">
                        <option value="Circle">Circle</option>
                        <option value="DKB">DKB</option>
                        <option value="Merc">Merc</option>
                    </select>
                </div>
                <button class="btn btn-primary" onclick="addPlayer()">Add Player</button>
            </div>

            <!-- Bulk Import Players -->
            <div class="action-card">
                <h3>üì• Bulk Import Players</h3>
                <p class="text-muted mb-md">Import players from CSV. Format: steam_id, name, team</p>
                <div class="import-zone" id="playerImportZone">
                    <div>üìÑ Drop CSV file here or click to upload</div>
                    <input type="file" id="playerFileInput" accept=".csv">
                </div>
                <div class="import-preview hidden" id="playerImportPreview"></div>
                <button class="btn btn-primary mt-md hidden" id="confirmPlayerImport" onclick="confirmPlayerImport()">
                    Import Players
                </button>
            </div>

            <!-- Import Match -->
            <div class="action-card">
                <h3>üéÆ Import Match</h3>
                <p class="text-muted mb-md">Paste match data from helo-system.de</p>
                
                <div class="form-group">
                    <label class="form-label">Lineup Sheet</label>
                    <select class="form-select" id="matchLineupSelect">
                        <option value="1">Lineup 1</option>
                        <option value="2">Lineup 2</option>
                        <option value="3">Lineup 3</option>
                        <option value="4">Lineup 4</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Team Page Data</label>
                    <textarea class="form-input" id="teamPasteData" rows="4" placeholder="Paste team page data here..."></textarea>
                </div>
                
                <div class="form-group">
                    <label class="form-label">CSV File (from helo-system.de)</label>
                    <input type="file" class="form-input" id="csvFileInput" accept=".csv,.txt" style="padding: 8px;">
                </div>
                
                <button class="btn btn-primary" onclick="previewMatchImport()">Preview Import</button>
            </div>

            <!-- Database Tools -->
            <div class="action-card">
                <h3>üèÜ My Team Divisions</h3>
                <p class="text-muted mt-sm mb-md" style="font-size: 11px;">
                    Tag your team with the leagues/divisions you play in. Used for comparison stats.
                </p>
                <div id="myTeamDivisionsContainer" style="margin-bottom: 16px;">
                    <div style="color: var(--text-secondary); font-size: 0.85rem;">Loading...</div>
                </div>
                <button class="btn btn-secondary btn-sm" onclick="openMyTeamDivisionPicker()" style="margin-bottom: 24px;">
                    ‚úèÔ∏è Edit My Divisions
                </button>
            </div>

            <!-- Manage Teams -->
            <div class="action-card">
                <h3>üè∑Ô∏è Manage Teams</h3>
                <p class="text-muted mt-sm mb-md" style="font-size: 11px;">
                    Manage known team names used in import dropdowns. Removing a team here does not delete match history.
                </p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                    <!-- My Teams -->
                    <div style="min-width: 0; overflow: hidden;">
                        <h4 style="font-size: 0.9rem; margin-bottom: 8px; color: var(--accent-orange);">My Teams</h4>
                        <div id="myTeamsList" style="margin-bottom: 8px;">
                            <div style="color: var(--text-secondary); font-size: 0.85rem;">Loading...</div>
                        </div>
                        <div style="display: flex; gap: 6px;">
                            <input type="text" id="addMyTeamInput" placeholder="New team name" 
                                style="flex: 1; min-width: 0; padding: 4px 8px; font-size: 12px; background: var(--bg-input, #1a1a2e); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);">
                            <button class="btn btn-secondary btn-sm" onclick="addMyTeam()" style="font-size: 11px; padding: 4px 8px; white-space: nowrap;">+ Add</button>
                        </div>
                    </div>
                    
                    <!-- Enemy Teams -->
                    <div style="min-width: 0; overflow: hidden;">
                        <h4 style="font-size: 0.9rem; margin-bottom: 8px; color: var(--accent-orange);">Enemy Teams</h4>
                        <div id="enemyTeamsList" style="margin-bottom: 8px;">
                            <div style="color: var(--text-secondary); font-size: 0.85rem;">Loading...</div>
                        </div>
                        <div style="display: flex; gap: 6px;">
                            <input type="text" id="addEnemyTeamInput" placeholder="New team tag" 
                                style="flex: 1; min-width: 0; padding: 4px 8px; font-size: 12px; background: var(--bg-input, #1a1a2e); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);">
                            <button class="btn btn-secondary btn-sm" onclick="addEnemyTeam()" style="font-size: 11px; padding: 4px 8px; white-space: nowrap;">+ Add</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card-body">
                <h3>üîß Database Tools</h3>
                
                <div class="mb-md">
                    <button class="btn btn-secondary" onclick="recalculateStats()">
                        üìä Recalculate All Stats
                    </button>
                    <p class="text-muted mt-sm" style="font-size: 11px;">
                        Recalculates all player statistics from match history.
                    </p>
                </div>
                
                <div class="mb-md">
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="exportBackup('json')">
                            üíæ Backup (JSON)
                        </button>
                        <button class="btn btn-secondary" onclick="exportBackup('csv')">
                            üìÑ Backup (CSV)
                        </button>
                        <button class="btn btn-secondary" onclick="exportBackup('both')">
                            üì¶ Backup (Both)
                        </button>
                    </div>
                    <p class="text-muted mt-sm" style="font-size: 11px;">
                        Downloads a full backup of all tables. JSON for re-import, CSV for Excel. "Both" gives a zip containing both formats.
                    </p>
                </div>
                
                <div>
                    <button class="btn btn-danger" onclick="clearAllLineups()">
                        üóëÔ∏è Clear All Lineups
                    </button>
                    <p class="text-muted mt-sm" style="font-size: 11px;">
                        Removes all current lineup assignments.
                    </p>
                </div>
            </div>
        </div>

        <!-- Import Preview Modal -->
        <div class="card mt-lg hidden" id="matchPreviewCard">
            <div class="card-header">
                <span class="card-title">Match Import Preview</span>
                <button class="btn btn-sm btn-secondary" onclick="cancelMatchImport()">Cancel</button>
            </div>
            <div class="card-body" id="matchPreviewBody">
                <!-- Populated by JS -->
            </div>
            <div style="padding: 16px; border-top: 1px solid var(--border-color); display: flex; gap: 8px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="cancelMatchImport()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmMatchImport()">Confirm Import</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay hidden" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading...</div>
    </div>

    <script src="../js/hll.js"></script>
    <script>
        // ============================================================================
        // STATE
        // ============================================================================
        
        let pendingPlayerImport = [];
        let pendingMatchImport = null;
        
        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        async function init() {
            await HLL.init();
            setupFileUpload();
        }
        
        function setupFileUpload() {
            const zone = document.getElementById('playerImportZone');
            const input = document.getElementById('playerFileInput');
            
            zone.addEventListener('click', () => input.click());
            
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('drag-over');
            });
            
            zone.addEventListener('dragleave', () => {
                zone.classList.remove('drag-over');
            });
            
            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('drag-over');
                const file = e.dataTransfer.files[0];
                if (file) processPlayerCSV(file);
            });
            
            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) processPlayerCSV(file);
            });
        }
        
        // ============================================================================
        // ADD SINGLE PLAYER
        // ============================================================================
        
        async function addPlayer() {
            let steamId = document.getElementById('newSteamId').value.trim();
            const name = document.getElementById('newPlayerName').value.trim();
            const team = document.getElementById('newPlayerTeam').value;
            
            if (!name) {
                HLL.showAlert('Please enter a player name', 'error');
                return;
            }
            
            // Generate temp ID if no SteamID provided
            if (!steamId) {
                steamId = 'TEMP-' + Math.random().toString(36).substr(2, 8).toUpperCase();
            }
            
            HLL.showLoading('Adding player...');
            
            const success = await HLL.createPlayer({
                steam_id: steamId,
                name: name,
                team: team
            });
            
            HLL.hideLoading();
            
            if (success) {
                const tempNote = steamId.startsWith('TEMP-') ? ' (no SteamID ‚Äî will pair on match import)' : '';
                HLL.showAlert('Player added successfully' + tempNote, 'success');
                document.getElementById('newSteamId').value = '';
                document.getElementById('newPlayerName').value = '';
            } else {
                HLL.showAlert('Failed to add player (may already exist)', 'error');
            }
        }
        
        // ============================================================================
        // BULK PLAYER IMPORT
        // ============================================================================
        
        function processPlayerCSV(file) {
            const reader = new FileReader();
            
            reader.onload = (e) => {
                const text = e.target.result;
                const lines = text.split('\n').filter(l => l.trim());
                
                // Skip header if present
                const startIndex = lines[0].toLowerCase().includes('steam') ? 1 : 0;
                
                pendingPlayerImport = [];
                
                for (let i = startIndex; i < lines.length; i++) {
                    const parts = lines[i].split(',').map(p => p.trim().replace(/^"|"$/g, ''));
                    
                    if (parts.length >= 2) {
                        pendingPlayerImport.push({
                            steam_id: parts[0],
                            name: stripClanTag(cleanPlayerName(parts[1])),
                            team: parts[2] || 'Merc'
                        });
                    }
                }
                
                // Show preview
                const preview = document.getElementById('playerImportPreview');
                preview.classList.remove('hidden');
                preview.innerHTML = `
                    <strong>${pendingPlayerImport.length} players found:</strong><br>
                    ${pendingPlayerImport.slice(0, 10).map(p => `${p.name} (${p.team})`).join('<br>')}
                    ${pendingPlayerImport.length > 10 ? `<br>... and ${pendingPlayerImport.length - 10} more` : ''}
                `;
                
                document.getElementById('confirmPlayerImport').classList.remove('hidden');
            };
            
            reader.readAsText(file);
        }
        
        function cleanPlayerName(name) {
            // Strip common clan tags
            return name
                .replace(/^‚óØ\s*\|\s*/i, '')
                .replace(/^„Äá\s*‰∏®\s*/i, '')
                .replace(/^\[DKB\]\s*/i, '')
                .replace(/^‚ìá\s*\|\s*/i, '')
                .replace(/^UKLL\s*\|\s*/i, '')
                .trim();
        }
        
        async function confirmPlayerImport() {
            if (pendingPlayerImport.length === 0) return;
            
            HLL.showLoading(`Importing ${pendingPlayerImport.length} players...`);
            
            try {
                const { error } = await HLL.supabase
                    .from('players')
                    .upsert(pendingPlayerImport, { 
                        onConflict: 'steam_id',
                        ignoreDuplicates: false 
                    });
                
                if (error) throw error;
                
                HLL.hideLoading();
                HLL.showAlert(`Imported ${pendingPlayerImport.length} players`, 'success');
                
                // Reset
                pendingPlayerImport = [];
                document.getElementById('playerImportPreview').classList.add('hidden');
                document.getElementById('confirmPlayerImport').classList.add('hidden');
                document.getElementById('playerFileInput').value = '';
                
            } catch (err) {
                console.error('Import error:', err);
                HLL.hideLoading();
                HLL.showAlert('Import failed: ' + err.message, 'error');
            }
        }
        
        // ============================================================================
        // MATCH IMPORT (placeholder - full implementation would mirror VBA logic)
        // ============================================================================
        
        // --- Fetch known team names for dropdowns ---
        async function getKnownTeams() {
            const teams = { myTeams: new Set(), enemyTeams: new Set() };
            try {
                // My teams from players table
                const { data: players } = await HLL.supabase.from('players').select('team');
                if (players) players.forEach(p => { if (p.team) teams.myTeams.add(p.team); });
                // My teams from matches
                const { data: matches } = await HLL.supabase.from('matches').select('my_team, enemy_team');
                if (matches) matches.forEach(m => {
                    if (m.my_team) teams.myTeams.add(m.my_team);
                    if (m.enemy_team) teams.enemyTeams.add(m.enemy_team);
                });
                // Enemy teams from enemy_teams table
                const { data: enemyTeams } = await HLL.supabase.from('enemy_teams').select('team_tag');
                if (enemyTeams) enemyTeams.forEach(t => { if (t.team_tag) teams.enemyTeams.add(t.team_tag); });
            } catch (e) { console.warn('Failed to load known teams:', e); }
            return { myTeams: [...teams.myTeams].sort(), enemyTeams: [...teams.enemyTeams].sort() };
        }

        async function previewMatchImport() {
            const teamData = document.getElementById('teamPasteData').value.trim();
            const csvFileInput = document.getElementById('csvFileInput');
            
            if (!teamData) {
                HLL.showAlert('Please paste team page data', 'error');
                return;
            }
            
            // Prompt for match type before processing
            const matchType = await selectMatchType();
            if (matchType === null) return; // cancelled
            window._pendingMatchType = matchType;
            
            // --- VALIDATE TEAM_PASTE DATA ---
            // Check for helo-system.de markers (case-insensitive, position-independent)
            const lowerTeamData = teamData.toLowerCase();
            const hasGameStats = lowerTeamData.includes('game statistics');
            const hasSearchPlayer = lowerTeamData.includes('search for a player');
            
            if (!hasGameStats || !hasSearchPlayer) {
                HLL.showAlert('This does not look like Team_Paste data from helo-system.de. Expected to find "Game statistics" and "Search for a player..." in the pasted text.', 'error');
                return;
            }
            
            // --- CHECK FOR COMBINED "TEAM" TAB ---
            // If paste has "Team\n" or "Team\r" as a standalone line before "Search for a player"
            // AND does NOT have "Allies (XX)" or "Axis (XX)", they pasted the combined view
            const factionLineMatch = teamData.match(/(Allies|Axis)\s*\((\d+)\)/i);
            if (!factionLineMatch) {
                HLL.showAlert('Could not detect your faction. Make sure you paste from the "Allies" or "Axis" tab on helo-system.de, NOT the combined "Team" tab.', 'error');
                return;
            }
            
            const pasteTeamFaction = factionLineMatch[1];
            const pastePlayerCount = factionLineMatch[2];
            
            // --- EXTRACT MATCH INFO FOR DISPLAY ---
            // Date: "November 23, 2025 8:02 PM" format
            const longDateMatch = teamData.match(/(\w+ \d{1,2},\s*\d{4}\s+\d{1,2}:\d{2}\s*[AP]M)/i);
            const isoDateMatch = teamData.match(/(\d{4}-\d{2}-\d{2})/);
            let pasteDate = 'Unknown date';
            if (longDateMatch) {
                pasteDate = longDateMatch[1];
            } else if (isoDateMatch) {
                pasteDate = isoDateMatch[1];
            }
            
            // Score: "5 : 0" with possible non-breaking spaces
            const normalizedPaste = teamData.replace(/\u00a0/g, ' ');
            const scoreMatch = normalizedPaste.match(/\b(\d)\s*[-‚Äì:]\s*(\d)\b/);
            let pasteScore = 'Unknown score';
            if (scoreMatch) {
                pasteScore = `${scoreMatch[1]} - ${scoreMatch[2]}`;
            }
            
            // Duration: H:MM:SS
            const durationMatch = teamData.match(/(\d{1,2}:\d{2}:\d{2})/);
            let pasteDuration = '';
            if (durationMatch) {
                pasteDuration = durationMatch[1];
            }
            
            // Map: search between the score/date area and "Game statistics"
            // Find the line that contains a map name AFTER the duration/date but BEFORE "Game statistics"
            const knownMaps = {
                'carentan': 'Carentan', 'foy': 'Foy', 'hill 400': 'Hill 400', 
                'hurtgen forest': 'Hurtgen Forest', 'h√ºrtgen forest': 'Hurtgen Forest',
                'kursk': 'Kursk', 'omaha beach': 'Omaha Beach', 'purple heart lane': 'Purple Heart Lane',
                'remagen': 'Remagen', 'sainte-m√®re-√©glise': 'SME', 'sainte m√®re √©glise': 'SME',
                'st. marie du mont': 'SMDM', 'sainte-marie-du-mont': 'SMDM',
                'stalingrad': 'Stalingrad', 'utah beach': 'Utah Beach', 'mortain': 'Mortain',
                'el alamein': 'El Alamein', 'driel': 'Driel', 'kharkov': 'Kharkov'
            };
            // Get text between date and "Game statistics" for map detection
            const gameStatsIdx = lowerTeamData.indexOf('game statistics');
            const mapSearchArea = gameStatsIdx > 0 ? lowerTeamData.substring(0, gameStatsIdx) : lowerTeamData;
            let pasteMap = 'Unknown map';
            // Sort by length descending so longer matches win
            const sortedMaps = Object.entries(knownMaps).sort((a, b) => b[0].length - a[0].length);
            for (const [alias, mapName] of sortedMaps) {
                if (mapSearchArea.includes(alias)) { pasteMap = mapName; break; }
            }
            
            // --- SHOW CONFIRMATION POPUP (Step 1) ---
            let confirmMsg = `Team_Paste detected:\n\n` +
                `  Faction: ${pasteTeamFaction} (${pastePlayerCount} players)\n` +
                `  Map: ${pasteMap}\n` +
                `  Score: ${pasteScore}\n` +
                `  Date: ${pasteDate}\n`;
            if (pasteDuration) confirmMsg += `  Duration: ${pasteDuration}\n`;
            confirmMsg += `\nIs this the correct match data?`;
            
            if (!confirm(confirmMsg)) {
                return;
            }
            
            if (!csvFileInput.files || !csvFileInput.files[0]) {
                HLL.showAlert('Please upload a CSV file', 'error');
                return;
            }
            
            // Read CSV file
            const csvData = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = () => reject(new Error('Failed to read CSV file'));
                reader.readAsText(csvFileInput.files[0]);
            });
            
            // --- PASTE/CSV CROSS-CHECK (Step 2) ---
            // Parse paste names and CSV names, check overlap
            const tempTeamInfo = parseTeamData(teamData);
            const tempCsvPlayers = parseCSVData(csvData);
            const csvNameSet = new Set(tempCsvPlayers.map(p => normalizeName(p.name)));
            const pasteInCsv = tempTeamInfo.friendlyNames.filter(n => csvNameSet.has(normalizeName(n)));
            const matchRate = tempTeamInfo.friendlyNames.length > 0 
                ? Math.round((pasteInCsv.length / tempTeamInfo.friendlyNames.length) * 100) 
                : 0;
            
            console.log(`[crossCheck] ${pasteInCsv.length}/${tempTeamInfo.friendlyNames.length} paste names found in CSV (${matchRate}%)`);
            
            if (pasteInCsv.length < 5) {
                const crossCheckMsg = `‚ö†Ô∏è Only ${pasteInCsv.length} of ${tempTeamInfo.friendlyNames.length} paste players found in CSV.\n\n` +
                    `This usually means the paste and CSV are from different games.\n\n` +
                    `Do you want to continue anyway?`;
                if (!confirm(crossCheckMsg)) {
                    return;
                }
            }
            
            HLL.showLoading('Processing match data...');
            
            try {
                // Step 1: Parse raw data
                const matchInfo = parseTeamData(teamData);
                const players = parseCSVData(csvData);
                const lineupNumber = document.getElementById('matchLineupSelect').value;
                
                if (players.length === 0) {
                    HLL.hideLoading();
                    HLL.showAlert('No players found in CSV data', 'error');
                    return;
                }
                
                // Step 2: Match players to roster (SteamID + Team_Paste names)
                await matchPlayersToRoster(players, matchInfo.friendlyNames);
                console.log(`[previewMatchImport] After roster match ‚Äî friendlyNames count: ${matchInfo.friendlyNames.length}`);
                
                // Step 3: Match players to lineup (sets roles, marks lineup players as friendly)
                const { lineupSlots } = await matchPlayersToLineup(players, lineupNumber, matchInfo);
                console.log(`[previewMatchImport] After lineup match ‚Äî friendly: ${players.filter(p=>p.isFriendly).length}, enemy: ${players.filter(p=>!p.isFriendly).length}`);
                
                // Step 4: Detect enemy team from [TAG] in enemy names
                matchInfo.enemyTeam = detectEnemyTeam(players);
                
                // Step 5: Determine result
                if (matchInfo.myScore != null && matchInfo.enemyScore != null) {
                    matchInfo.result = matchInfo.myScore > matchInfo.enemyScore ? 'W' :
                                       matchInfo.myScore < matchInfo.enemyScore ? 'L' : 'D';
                }
                
                // Step 6: Detect no-shows
                const noShows = detectNoShows(players, lineupSlots);
                
                // Step 7: Calculate MVP
                const mvp = calculateMVP(players, matchInfo.duration);
                
                // Step 8: Detect TEMP players that can be paired with real SteamIDs
                const { data: rosterPlayers } = await HLL.supabase
                    .from('players')
                    .select('steam_id, name');
                const tempPlayers = (rosterPlayers || []).filter(p => p.steam_id.startsWith('TEMP-'));
                
                const pairings = [];
                if (tempPlayers.length > 0) {
                    const normalizeName = s => (s || '').replace(/[^a-z0-9]/gi, '').toLowerCase();
                    const friendlyPlayers = players.filter(p => p.isFriendly);
                    
                    for (const tp of tempPlayers) {
                        const match = friendlyPlayers.find(fp => 
                            normalizeName(fp.name) === normalizeName(tp.name) && fp.steamId
                        );
                        if (match) {
                            // Check the real SteamID isn't already in roster
                            const alreadyExists = (rosterPlayers || []).some(rp => rp.steam_id === match.steamId);
                            if (!alreadyExists) {
                                pairings.push({
                                    tempId: tp.steam_id,
                                    realSteamId: match.steamId,
                                    playerName: tp.name,
                                    approved: true // default checked
                                });
                            }
                        }
                    }
                }
                
                // Step 9: Validate
                const errors = [];
                const friendlyPlayers = players.filter(p => p.isFriendly);
                const enemyPlayers = players.filter(p => !p.isFriendly);
                
                if (!matchInfo.map) errors.push({ type: 'WARNING', msg: 'Could not detect map from team data' });
                if (!matchInfo.myFaction) errors.push({ type: 'WARNING', msg: 'Could not detect faction' });
                if (friendlyPlayers.length === 0) errors.push({ type: 'CRITICAL', msg: 'No friendly players detected' });
                if (!matchInfo.myScore && matchInfo.myScore !== 0) errors.push({ type: 'WARNING', msg: 'Could not detect score' });
                if (noShows.length > 0) errors.push({ type: 'INFO', msg: `${noShows.length} no-show(s) detected` });
                if (pairings.length > 0) errors.push({ type: 'INFO', msg: `${pairings.length} player(s) can be paired with SteamIDs` });
                
                const hasCritical = errors.some(e => e.type === 'CRITICAL');
                
                // Store for confirmMatchImport
                pendingMatchImport = {
                    matchInfo,
                    players,
                    lineupNumber,
                    noShows,
                    mvp,
                    friendlyPlayers,
                    enemyPlayers,
                    errors,
                    pairings
                };
                
                HLL.hideLoading();
                
                // Build preview HTML
                const previewCard = document.getElementById('matchPreviewCard');
                const previewBody = document.getElementById('matchPreviewBody');
                
                // Fetch known teams for dropdowns
                const knownTeams = await getKnownTeams();
                
                const resultColor = matchInfo.result === 'W' ? '#4ade80' : matchInfo.result === 'L' ? '#f87171' : '#fbbf24';
                const resultLabel = matchInfo.result === 'W' ? 'WIN' : matchInfo.result === 'L' ? 'LOSS' : matchInfo.result === 'D' ? 'DRAW' : '?';
                
                previewBody.innerHTML = `
                    ${errors.length > 0 ? `
                        <div style="background: ${hasCritical ? 'rgba(248,113,113,0.15)' : 'rgba(251,191,36,0.15)'}; border: 1px solid ${hasCritical ? '#f87171' : '#fbbf24'}; border-radius: 6px; padding: 10px; margin-bottom: 16px;">
                            <strong>${hasCritical ? '‚õî Critical Issues' : '‚ö†Ô∏è Warnings'}:</strong>
                            ${errors.map(e => `<div style="margin-top: 4px; font-size: 12px;">[${e.type}] ${e.msg}</div>`).join('')}
                        </div>
                    ` : ''}
                    
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 16px;">
                        <div class="stat-box">
                            <span class="stat-value">${matchInfo.map || '?'}</span>
                            <span class="stat-label">Map</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value" style="color: ${resultColor}">${matchInfo.myScore ?? '?'} - ${matchInfo.enemyScore ?? '?'}</span>
                            <span class="stat-label">Score (${resultLabel})</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value">${matchInfo.myFaction || '?'}</span>
                            <span class="stat-label">Faction</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value">${matchInfo.duration || '?'}</span>
                            <span class="stat-label">Duration</span>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 16px;">
                        <div class="stat-box">
                            <span class="stat-value">${matchInfo.date || '?'}</span>
                            <span class="stat-label">Date</span>
                        </div>
                        <div class="stat-box">
                            <select id="myTeamInput" 
                                style="background: var(--bg-input, #1a1a2e); border: 1px solid var(--accent-orange); border-radius: 4px; color: var(--text-primary); font-size: 1.1rem; font-weight: 700; text-align: center; width: 100%; padding: 4px 8px;"
                                onchange="if(this.value==='__custom__'){const v=prompt('Enter team name:');if(v){const o=document.createElement('option');o.value=v.trim();o.textContent=v.trim();this.insertBefore(o,this.lastElementChild);this.value=v.trim();}else{this.value='${HLL.currentTeam || 'Circle'}';}}"
                            >
                                ${knownTeams.myTeams.map(t => `<option value="${t}" ${t === (HLL.currentTeam || 'Circle') ? 'selected' : ''}>${t}</option>`).join('')}
                                ${!knownTeams.myTeams.includes(HLL.currentTeam || 'Circle') ? `<option value="${HLL.currentTeam || 'Circle'}" selected>${HLL.currentTeam || 'Circle'}</option>` : ''}
                                <option value="__custom__">+ Add new...</option>
                            </select>
                            <span class="stat-label">My Team</span>
                        </div>
                        <div class="stat-box">
                            <select id="enemyTeamInput" 
                                style="background: var(--bg-input, #1a1a2e); border: 1px solid var(--accent-orange); border-radius: 4px; color: var(--text-primary); font-size: 1.1rem; font-weight: 700; text-align: center; width: 100%; padding: 4px 8px;"
                                onchange="if(this.value==='__custom__'){const v=prompt('Enter enemy team name:');if(v){const o=document.createElement('option');o.value=v.trim();o.textContent=v.trim();this.insertBefore(o,this.lastElementChild);this.value=v.trim();}else{this.value=this.options[0]?.value||'';}}"
                            >
                                ${(() => {
                                    const detected = matchInfo.enemyTeam || '';
                                    const allEnemy = [...new Set([...knownTeams.enemyTeams, ...(detected ? [detected] : [])])].sort();
                                    return allEnemy.map(t => `<option value="${t}" ${t === detected ? 'selected' : ''}>${t}</option>`).join('');
                                })()}
                                <option value="__custom__">+ Add new...</option>
                            </select>
                            <span class="stat-label">Enemy Team</span>
                        </div>
                        <div class="stat-box">
                            <select id="matchTypeInput" 
                                style="background: var(--bg-input, #1a1a2e); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 1rem; font-weight: 700; text-align: center; width: 100%; padding: 4px 8px;">
                                ${await (async () => {
                                    let divs = [];
                                    try {
                                        const { data } = await HLL.supabase.from('divisions').select('name').order('sort_order', { ascending: true });
                                        divs = data || [];
                                    } catch(e) {}
                                    const options = ['Friendly', ...divs.map(d => d.name)];
                                    const selected = window._pendingMatchType || 'Friendly';
                                    return options.map(o => `<option value="${o}" ${o === selected ? 'selected' : ''}>${o}</option>`).join('');
                                })()}
                            </select>
                            <span class="stat-label">Match Type</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value">${mvp ? mvp.name : '‚Äî'}</span>
                            <span class="stat-label">MVP (PPS: ${mvp ? mvp.pps : '‚Äî'})</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value">${noShows.length}</span>
                            <span class="stat-label">No-Shows</span>
                        </div>
                    </div>
                    
                    <h4 style="margin-bottom: 8px;">Friendly Players: ${friendlyPlayers.length}</h4>
                    <div class="table-container" style="max-height: 250px; overflow: auto; margin-bottom: 16px;">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Role</th>
                                    <th>Kills</th>
                                    <th>Deaths</th>
                                    <th>K/D</th>
                                    <th>CE</th>
                                    <th>Support</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${friendlyPlayers.map(p => `
                                    <tr${mvp && p.steamId === mvp.steamId ? ' style="background: rgba(251,191,36,0.1);"' : ''}>
                                        <td>${p.name}${mvp && p.steamId === mvp.steamId ? ' ‚≠ê' : ''}</td>
                                        <td>${p.role || '‚Äî'}</td>
                                        <td>${p.kills}</td>
                                        <td>${p.deaths}</td>
                                        <td>${p.kd.toFixed(2)}</td>
                                        <td>${p.ce}</td>
                                        <td>${p.support}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    
                    <h4 style="margin-bottom: 8px;">Enemy Players: ${enemyPlayers.length}</h4>

                    ${(() => {
                        const newPlayers = friendlyPlayers.filter(p => p.isNew);
                        if (newPlayers.length === 0) return '';
                        return `
                        <div style="background: rgba(251,191,36,0.08); border: 1px solid rgba(251,191,36,0.3); border-radius: 6px; padding: 12px; margin-bottom: 16px;">
                            <h4 style="margin: 0 0 4px; color: #fbbf24;">‚ö†Ô∏è New Players: ${newPlayers.length}</h4>
                            <p style="font-size: 11px; color: var(--text-secondary); margin: 0 0 10px;">These players are not yet in your roster. Assign them to a team before importing.</p>
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <span style="font-size: 11px; color: var(--text-secondary);">Set all to:</span>
                                <select id="newPlayerBulkTeam" style="padding: 3px 6px; font-size: 12px; background: var(--bg-input, #1a1a2e); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);"
                                    onchange="document.querySelectorAll('.new-player-team').forEach(s => s.value = this.value)">
                                    ${knownTeams.myTeams.map(t => `<option value="${t}" ${t === (HLL.currentTeam || 'Circle') ? 'selected' : ''}>${t}</option>`).join('')}
                                </select>
                            </div>
                            <div style="max-height: 200px; overflow-y: auto;">
                                ${newPlayers.map((p, i) => `
                                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.05);">
                                        <span style="font-size: 0.85rem;">${p.name}</span>
                                        <select class="new-player-team" data-steamid="${p.steamId}" 
                                            style="padding: 3px 6px; font-size: 12px; background: var(--bg-input, #1a1a2e); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); min-width: 100px;">
                                            ${knownTeams.myTeams.map(t => `<option value="${t}" ${t === (HLL.currentTeam || 'Circle') ? 'selected' : ''}>${t}</option>`).join('')}
                                        </select>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        `;
                    })()}
                    <div class="table-container" style="max-height: 200px; overflow: auto; margin-bottom: 16px;">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Kills</th>
                                    <th>Deaths</th>
                                    <th>K/D</th>
                                    <th>CE</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${enemyPlayers.slice(0, 30).map(p => `
                                    <tr>
                                        <td>${p.name}</td>
                                        <td>${p.kills}</td>
                                        <td>${p.deaths}</td>
                                        <td>${p.kd.toFixed(2)}</td>
                                        <td>${p.ce}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    
                    ${noShows.length > 0 ? `
                        <h4 style="margin-bottom: 8px; color: #f87171;">No-Shows: ${noShows.length}</h4>
                        <div style="margin-bottom: 16px; font-size: 13px;">
                            ${noShows.map(ns => `<div style="padding: 2px 0;">‚Ä¢ ${ns.playerName || ns.steamId} (${ns.role})</div>`).join('')}
                        </div>
                    ` : ''}
                    
                    ${pairings.length > 0 ? `
                        <h4 style="margin-bottom: 8px; color: #f5a623;">üîó SteamID Pairing: ${pairings.length} player(s)</h4>
                        <div style="background: rgba(245,166,35,0.1); border: 1px solid #f5a623; border-radius: 6px; padding: 10px; margin-bottom: 16px; font-size: 13px;">
                            <div style="margin-bottom: 8px; color: #8b949e;">These players were added without a SteamID and can now be paired:</div>
                            ${pairings.map((p, i) => `
                                <div style="display: flex; align-items: center; gap: 8px; padding: 4px 0;">
                                    <input type="checkbox" id="pairing-${i}" checked style="accent-color: #f5a623;">
                                    <label for="pairing-${i}" style="flex: 1;">
                                        <strong>${p.playerName}</strong>
                                        <span style="color: #8b949e;"> ‚Üí ${p.realSteamId}</span>
                                    </label>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${hasCritical ? '<p style="color: #f87171; font-weight: bold;">‚õî Critical issues found. Import may produce incomplete data.</p>' : ''}
                `;
                
                previewCard.classList.remove('hidden');
                previewCard.scrollIntoView({ behavior: 'smooth' });
                
            } catch (err) {
                HLL.hideLoading();
                console.error('Preview error:', err);
                HLL.showAlert('Failed to process match data: ' + err.message, 'error');
            }
        }
        
        function parseTeamData(text) {
            // Full parsing of helo-system.de team page paste
            const info = {
                map: null,
                myScore: null,
                enemyScore: null,
                myFaction: null,
                enemyFaction: null,
                duration: null,
                date: null,
                enemyTeam: null,
                friendlyNames: []   // player names detected from team paste
            };

            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            const fullText = lines.join(' ');
            const lowerText = fullText.toLowerCase();

            // --- MAP DETECTION (case-insensitive, handle abbreviations) ---
            const mapAliases = {
                'carentan': 'Carentan', 'foy': 'Foy', 'hill 400': 'Hill 400',
                'hurtgen': 'Hurtgen Forest', 'h√ºrtgen': 'Hurtgen Forest',
                'kursk': 'Kursk', 'omaha': 'Omaha Beach', 'purple heart': 'Purple Heart Lane',
                'remagen': 'Remagen', 'sainte m√®re': 'SME', 'sainte-m√®re': 'SME',
                'sme': 'SME', 'st marie': 'SMDM', 'st. marie': 'SMDM', 'smdm': 'SMDM',
                'sainte-marie-du-mont': 'SMDM', 'stalingrad': 'Stalingrad',
                'utah': 'Utah Beach', 'mortain': 'Mortain', 'el alamein': 'El Alamein',
                'driel': 'Driel', 'kharkov': 'Kharkov'
            };
            // Sort by alias length descending so longer matches win (e.g. "hill 400" before "hill")
            const sortedAliases = Object.entries(mapAliases).sort((a, b) => b[0].length - a[0].length);
            for (const [alias, mapName] of sortedAliases) {
                if (lowerText.includes(alias)) { info.map = mapName; break; }
            }

            // --- DATE DETECTION ---
            // Try YYYY-MM-DD first, then DD/MM/YYYY, DD.MM.YYYY
            const datePatterns = [
                { re: /(\d{4}-\d{2}-\d{2})/, fmt: 'iso' },
                { re: /(\d{1,2})[\/.](\d{1,2})[\/.](\d{4})/, fmt: 'dmy4' },
                { re: /(\d{1,2})[\/.](\d{1,2})[\/.](\d{2})/, fmt: 'dmy2' }
            ];
            for (const { re, fmt } of datePatterns) {
                const m = fullText.match(re);
                if (m) {
                    if (fmt === 'iso') {
                        info.date = m[1];
                    } else {
                        const yr = fmt === 'dmy2' ? '20' + m[3] : m[3];
                        info.date = `${yr}-${m[2].padStart(2, '0')}-${m[1].padStart(2, '0')}`;
                    }
                    break;
                }
            }
            if (!info.date) info.date = new Date().toISOString().split('T')[0];

            // --- SCORE (X:Y or X-Y or X ‚Äì Y, single digits 0-5) ---
            // Normalize non-breaking spaces (U+00A0) that helo-system uses
            const normalizedText = fullText.replace(/\u00a0/g, ' ');
            const scoreMatch = normalizedText.match(/\b(\d)\s*[-‚Äì:]\s*(\d)\b/);
            if (scoreMatch) {
                info.myScore = parseInt(scoreMatch[1]);
                info.enemyScore = parseInt(scoreMatch[2]);
            }

            // --- FACTION ---
            // VBA ParseFaction requires both faction word AND parenthesis in same text
            // e.g. "Axis (49)" or "Allies (50)" ‚Äî this is the selected faction tab on helo-system
            // Simple "Allies" or "Axis" without parenthesis are just labels, not your faction
            for (const line of lines) {
                const lower = line.toLowerCase().replace(/\u00a0/g, ' ');
                if (lower.includes('(') && lower.includes(')')) {
                    if (lower.includes('allies')) {
                        info.myFaction = 'Allies';
                        info.enemyFaction = 'Axis';
                        break;
                    } else if (lower.includes('axis')) {
                        info.myFaction = 'Axis';
                        info.enemyFaction = 'Allies';
                        break;
                    }
                }
            }
            // Fallback: if no parenthesized faction found, try simple match
            if (!info.myFaction) {
                if (lowerText.includes('allies')) {
                    info.myFaction = 'Allies';
                    info.enemyFaction = 'Axis';
                } else if (lowerText.includes('axis')) {
                    info.myFaction = 'Axis';
                    info.enemyFaction = 'Allies';
                }
            }

            // --- DURATION (H:MM:SS or HH:MM:SS) ---
            const durMatch = fullText.match(/(\d{1,2}:\d{2}:\d{2})/);
            if (durMatch) info.duration = durMatch[1];

            // --- ENEMY TEAM NAME ---
            // Not detected here. Derived from enemy player clan tags after CSV parsing
            // (mirrors VBA DetectEnemyTeam which scans [TAG] in enemy player names)

            // --- FRIENDLY PLAYER NAMES ---
            // Browser paste from helo-system: each player spans multiple lines
            // Pattern: RANK ‚Üí NAME ‚Üí KILLS ‚Üí KD ‚Üí DEATHS ‚Üí next RANK...
            // STRICT: rank must be exactly expectedRank to avoid deaths/kills confusion
            // Validate: after name, next numeric line must exist (kills count)
            const allLines = text.split('\n');
            let playerStartIdx = 0;
            for (let si = 0; si < allLines.length; si++) {
                if (allLines[si].toLowerCase().includes('search for a player')) {
                    playerStartIdx = si + 1;
                    break;
                }
            }
            let expectedRank = 1;
            let pi = playerStartIdx;
            while (pi < allLines.length) {
                const stripped = allLines[pi].replace(/[\s\u00a0\t]+/g, ' ').trim();
                const lower = stripped.toLowerCase();
                if (lower.includes('select a player') || lower.includes('made by')) break;
                const cleaned = stripped.replace(/[\s\u00a0\t]/g, '');
                // Strict: rank must be exactly expectedRank
                if (/^\d+$/.test(cleaned) && parseInt(cleaned) === expectedRank && expectedRank <= 50) {
                    const rankNum = parseInt(cleaned);
                    let foundName = false;
                    for (let nj = pi + 1; nj < Math.min(pi + 4, allLines.length); nj++) {
                        const candidate = allLines[nj].replace(/[\s\u00a0\t]+/g, ' ').trim();
                        if (!candidate) continue;
                        const candClean = candidate.replace(/[\s\u00a0\t]/g, '');
                        // Skip pure numbers/decimals (stats values)
                        if (/^[\d.]+$/.test(candClean)) continue;
                        // Must contain at least one letter
                        if (!/\p{L}/u.test(candidate)) continue;
                        // Validate: next line after name should be numeric (kills)
                        for (let vk = nj + 1; vk < Math.min(nj + 4, allLines.length); vk++) {
                            const verify = allLines[vk].replace(/[\s\u00a0\t]/g, '');
                            if (!verify) continue; // skip empty lines
                            if (/^\d+$/.test(verify)) {
                                info.friendlyNames.push(candidate);
                                expectedRank = rankNum + 1;
                                pi = vk + 1;
                                foundName = true;
                                break;
                            }
                        }
                        if (foundName) break;
                    }
                    if (foundName) continue;
                }
                pi++;
            }
            console.log(`[parseTeamData] Total lines: ${allLines.length}, Names extracted: ${info.friendlyNames.length}`);
            if (info.friendlyNames.length > 0) {
                console.log(`[parseTeamData] First 5 names:`, info.friendlyNames.slice(0, 5));
            }
            if (info.friendlyNames.length === 0 && allLines.length > 10) {
                console.warn(`[parseTeamData] ‚ö†Ô∏è No friendly names extracted! Could not find "Search for a player" marker or rank pattern.`);
            }

            return info;
        }
        
        function parseCSVData(text) {
            const lines = text.split('\n').filter(l => l.trim());
            const players = [];
            
            if (lines.length < 2) return players;
            
            // Detect delimiter: tab or comma
            const headerLine = lines[0];
            const isTab = headerLine.includes('\t');
            
            // Skip header row (row 0)
            for (let i = 1; i < lines.length; i++) {
                // Use proper CSV parsing for comma-delimited (handles quoted JSON fields)
                const parts = isTab
                    ? lines[i].split('\t').map(p => p.trim().replace(/^"|"$/g, ''))
                    : parseCSVLine(lines[i]);
                
                if (parts.length < 5) continue;
                
                // Column mapping matches VBA Raw_Paste constants (RP_*)
                // Index: 0=SteamID, 1=Name, 2=Kills, 3=Deaths, 4=K/D,
                // 5=MaxStreak, 6=KPM, 7=DPM, 8=MaxDeath, 9=MaxTK, 10=DeathByTK,
                // 11=DeathByTKStreak(skip), 12=LongLife, 13=ShortLife,
                // 14=Nemesis(skip), 15=Victim(skip), 16=CE, 17=Support,
                // 18=Defensive, 19=Offensive
                players.push({
                    steamId:        parts[0] || '',
                    name:           (parts[1] || '').trim(),
                    kills:          parseInt(parts[2]) || 0,
                    deaths:         parseInt(parts[3]) || 0,
                    kd:             parseFloat(parts[4]) || 0,
                    maxKillStreak:  parseInt(parts[5]) || 0,
                    kpm:            parseFloat(parts[6]) || 0,
                    dpm:            parseFloat(parts[7]) || 0,
                    maxDeathStreak: parseInt(parts[8]) || 0,
                    maxTkStreak:    parseInt(parts[9]) || 0,
                    deathByTk:      parseInt(parts[10]) || 0,
                    longestLifeMin: parseFloat(parts[12]) || 0,
                    shortestLifeSec:parseInt(parts[13]) || 0,
                    ce:             parseInt(parts[16]) || 0,
                    support:        parseInt(parts[17]) || 0,
                    defensive:      parseInt(parts[18]) || 0,
                    offensive:      parseInt(parts[19]) || 0,
                    // These will be set by later processing steps
                    isFriendly:     false,
                    role:           '',
                    faction:        ''
                });
            }
            
            return players;
        }
        
        /**
         * Parse a CSV line handling quoted fields (e.g., JSON columns with commas).
         * Handles "" as escaped quotes within quoted fields.
         */
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const c = line[i];
                if (c === '"') {
                    if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
                        current += '"';
                        i++; // skip escaped quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (c === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += c;
                }
            }
            result.push(current.trim());
            
            return result;
        }
        
        // ============================================================================
        // MATCH PROCESSING (mirrors VBA: MatchPlayersToRoster, MatchPlayersToLineup,
        //                   DetectNoShows, CalculateMVP, DetectEnemyTeam)
        // ============================================================================
        
        /**
         * Cross-reference CSV players with roster SteamIDs + Team_Paste names.
         * Sets isFriendly flag on each player.
         * Mirrors VBA v5.5.23 MatchPlayersToRoster:
         *   Check 1: SteamID exists in roster ‚Üí friendly
         *   Check 2: Name matches Team_Paste ‚Üí friendly (catches new players)
         *   Everyone else ‚Üí enemy
         * New friendly players are auto-added to roster after import.
         */
        async function matchPlayersToRoster(players, friendlyNames) {
            // Build roster SteamID set from Supabase
            const { data: rosterPlayers } = await HLL.supabase
                .from('players')
                .select('steam_id, name');
            
            const rosterSteamIds = new Set((rosterPlayers || []).map(p => p.steam_id));
            
            // Normalize friendly names from Team_Paste
            const normalizedFriendly = new Set(
                (friendlyNames || []).map(n => normalizeName(n))
            );
            
            // Debug logging
            console.log(`[matchPlayersToRoster] Roster SteamIDs in DB: ${rosterSteamIds.size}`);
            console.log(`[matchPlayersToRoster] Team_Paste friendly names: ${normalizedFriendly.size}`);
            if (normalizedFriendly.size > 0) {
                console.log(`[matchPlayersToRoster] First 5 friendly names:`, [...normalizedFriendly].slice(0, 5));
            }
            if (normalizedFriendly.size === 0) {
                console.warn(`[matchPlayersToRoster] ‚ö†Ô∏è NO friendly names from Team_Paste! Check parseTeamData.`);
            }
            
            let matchedBySteam = 0;
            let matchedByName = 0;
            
            for (const player of players) {
                // Check 1: SteamID in roster ‚Üí friendly
                if (rosterSteamIds.has(player.steamId)) {
                    player.isFriendly = true;
                    matchedBySteam++;
                }
                // Check 2: Name in Team_Paste ‚Üí friendly (catches new players)
                else if (normalizedFriendly.has(normalizeName(player.name))) {
                    player.isFriendly = true;
                    player.isNew = true; // Not in roster yet
                    matchedByName++;
                }
            }
            
            const totalFriendly = players.filter(p => p.isFriendly).length;
            const totalEnemy = players.filter(p => !p.isFriendly).length;
            console.log(`[matchPlayersToRoster] Matched: ${matchedBySteam} by SteamID, ${matchedByName} by name`);
            console.log(`[matchPlayersToRoster] Result: ${totalFriendly} friendly, ${totalEnemy} enemy`);
            
            // Debug: show unmatched paste names
            if (totalFriendly < normalizedFriendly.size) {
                const csvNormalized = new Set(players.map(p => normalizeName(p.name)));
                const unmatchedPaste = (friendlyNames || []).filter(n => !csvNormalized.has(normalizeName(n)));
                if (unmatchedPaste.length > 0) {
                    console.warn(`[matchPlayersToRoster] ‚ö†Ô∏è ${unmatchedPaste.length} paste names NOT found in CSV (may have left match):`);
                    unmatchedPaste.forEach(n => console.log(`  Paste: "${n}" -> normalized: "${normalizeName(n)}"`));
                }
            }
        }
        
        /**
         * Normalize name for comparison: strip non-alphanumeric, lowercase.
         * Mirrors VBA NormalizeName (line 661).
         */
        function normalizeName(name) {
            return (name || '').replace(/[^\p{L}\p{N}]/gu, '').toLowerCase();
        }
        
        /**
         * Get role assignments from the selected lineup in Supabase.
         * Sets role and faction on each player.
         * Also marks lineup players as friendly.
         * Mirrors VBA MatchPlayersToLineup (line 690).
         */
        async function matchPlayersToLineup(players, lineupNumber, matchInfo) {
            // Get lineup data from Supabase
            const { data: lineupSlots } = await HLL.supabase
                .from('lineups')
                .select('cell_position, steam_id, player_name, role, sl_role, note')
                .eq('lineup_number', parseInt(lineupNumber));
            
            // Build lookup: steam_id ‚Üí role info, and name ‚Üí role info (fallback)
            const steamToRole = {};
            const nameToRole = {};
            const lineupSteamIds = new Set();
            const lineupNames = new Set();
            
            for (const slot of (lineupSlots || [])) {
                const roleInfo = {
                    role: slot.role || getRoleFromCellPosition(slot.cell_position),
                    cell_position: slot.cell_position || null,
                    section: getSectionFromCellPosition(slot.cell_position),
                    sl_role: slot.sl_role || null,
                    note: slot.note || null
                };
                if (slot.steam_id) {
                    steamToRole[slot.steam_id] = roleInfo;
                    lineupSteamIds.add(slot.steam_id);
                }
                if (slot.player_name) {
                    nameToRole[normalizeName(slot.player_name)] = roleInfo;
                    lineupNames.add(normalizeName(slot.player_name));
                }
            }
            
            // Match players to lineup roles
            for (const player of players) {
                const info = steamToRole[player.steamId] || nameToRole[normalizeName(player.name)];
                if (info) {
                    player.isFriendly = true;
                    player.role = info.role;
                    player.cell_position = info.cell_position;
                    player.section = info.section;
                    player.sl_role = info.sl_role;
                    player.note = info.note;
                }
                
                // Set faction based on friendly/enemy
                player.faction = player.isFriendly
                    ? (matchInfo.myFaction || 'Allies')
                    : (matchInfo.enemyFaction || 'Axis');
            }
            
            return { lineupSteamIds, lineupNames, lineupSlots: lineupSlots || [] };
        }
        
        /**
         * Derive role from data-cell position.
         * Maps cell IDs like 'cmd-1', 't1-tc', 'nw-3' to role names.
         */
        function getRoleFromCellPosition(cellPos) {
            if (!cellPos) return 'Infantry';
            const pos = cellPos.toLowerCase();
            
            if (pos.startsWith('cmd'))  return 'Commander';
            if (pos.startsWith('art'))  return 'Artillery';
            if (pos.startsWith('str'))  return 'Streamer';
            if (pos.includes('-tc'))    return 'TC';
            if (pos.includes('-gun'))   return 'Gunner';
            if (pos.includes('-drv'))   return 'Driver';
            if (pos.includes('-spot')) return 'Spotter';
            if (pos.includes('-snip')) return 'Sniper';
            if (pos.startsWith('nn-') || pos.startsWith('nm-') || pos.startsWith('ns-')) return 'Nodes';
            // Section-specific infantry
            if (pos.startsWith('def-'))  return 'Defence';
            if (pos.startsWith('nw-'))   return 'Infantry';
            if (pos.startsWith('mg-'))   return 'Infantry';
            if (pos.startsWith('flx-'))  return 'Infantry';
            if (pos.startsWith('se-'))   return 'Infantry';
            if (pos.startsWith('inf-'))  return 'Infantry';
            return 'Infantry';
        }
        
        /**
         * Get the squad/section name from cell position.
         */
        function getSectionFromCellPosition(cellPos) {
            if (!cellPos) return null;
            const pos = cellPos.toLowerCase();
            if (pos.startsWith('cmd'))  return 'Command';
            if (pos.startsWith('art'))  return 'Artillery';
            if (pos.startsWith('str'))  return 'Streamer';
            if (pos.startsWith('t1-'))  return 'Tank 1';
            if (pos.startsWith('t2-'))  return 'Tank 2';
            if (pos.startsWith('t3-'))  return 'Tank 3';
            if (pos.startsWith('t4-'))  return 'Tank 4';
            if (pos.startsWith('r1-'))  return 'Recon 1';
            if (pos.startsWith('r2-'))  return 'Recon 2';
            if (pos.startsWith('nw-'))  return 'North/West';
            if (pos.startsWith('def-')) return 'Defence';
            if (pos.startsWith('mg-'))  return 'Meat Grind';
            if (pos.startsWith('flx-')) return 'Flex';
            if (pos.startsWith('se-'))  return 'South/East';
            if (pos.startsWith('inf-')) return 'Infiltration';
            if (pos.startsWith('nn-'))  return 'Nodes North';
            if (pos.startsWith('nm-'))  return 'Nodes Middle';
            if (pos.startsWith('ns-'))  return 'Nodes South';
            return null;
        }
        
        /**
         * Detect players in lineup but not in game data.
         * Returns array of no-show objects.
         * Mirrors VBA DetectNoShows (line 762).
         */
        function detectNoShows(players, lineupSlots) {
            const gameSteamIds = new Set(players.map(p => p.steamId));
            const gameNames = new Set(players.map(p => normalizeName(p.name)));
            const noShows = [];
            
            for (const slot of lineupSlots) {
                if (!slot.player_name && !slot.steam_id) continue;
                
                // Check if this lineup player appeared in the game
                const inGameBySteam = slot.steam_id && gameSteamIds.has(slot.steam_id);
                const inGameByName = slot.player_name && gameNames.has(normalizeName(slot.player_name));
                
                if (!inGameBySteam && !inGameByName) {
                    noShows.push({
                        steamId: slot.steam_id || '',
                        playerName: slot.player_name || '',
                        role: slot.role || getRoleFromCellPosition(slot.cell_position)
                    });
                }
            }
            
            return noShows;
        }
        
        /**
         * Find MVP: highest PPS among friendly players, excluding Artillery.
         * PPS = Player Performance Score inspired by hellor.pro H-Score.
         */
        function calculateMVP(players, matchDuration) {
            let mvp = null;
            let maxPPS = 0;
            
            for (const player of players) {
                if (!player.isFriendly || player.role === 'Artillery') continue;
                
                const pps = calculatePPS(player, matchDuration);
                player.pps = pps;
                
                if (pps > maxPPS) {
                    maxPPS = pps;
                    mvp = player;
                }
            }
            
            return mvp;
        }

        /**
         * Calculate Player Performance Score (PPS) for a single match.
         * Formula inspired by hellor.pro H-Score, normalized by duration.
         */
        function calculatePPS(p, duration) {
            const kd = p.kd || 0;
            const kpm = p.kpm || 0;
            const ce = p.ce || 0;
            const off = p.offensive || 0;
            const def = p.defensive || 0;
            const sup = p.support || 0;
            
            const kdFactor = Math.min(2.5, Math.max(0.3, kd / 1.5));
            const kpmFactor = Math.min(2.5, Math.max(0.3, kpm / 0.8));
            const supportFactor = 1.0 / (1.0 + sup / 5000);
            
            // Parse duration H:MM:SS to seconds, default 5400 (90 min)
            let durationSecs = 5400;
            if (duration) {
                const parts = duration.split(':').map(Number);
                if (parts.length === 3) durationSecs = parts[0] * 3600 + parts[1] * 60 + parts[2];
            }
            durationSecs = Math.max(1, durationSecs);
            
            const rawScore = 
                (ce * 4.0 * kdFactor * kpmFactor) +
                (off * 0.9 * kdFactor * kpmFactor) +
                (def * 1.1 * kdFactor * kpmFactor) +
                (sup * 2.0 * supportFactor);
            
            return Math.round((rawScore / durationSecs) * 100) / 100;
        }
        
        /**
         * Detect enemy team name from most common [TAG] in enemy player names.
         * Mirrors VBA DetectEnemyTeam (line 539).
         */
        function detectEnemyTeam(players) {
            const tagCounts = {};
            
            for (const player of players) {
                if (player.isFriendly) continue;
                
                const match = player.name.match(/\[([A-Za-z0-9]{2,10})\]/);
                if (match) {
                    const tag = match[1];
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                }
            }
            
            let maxTag = 'Unknown';
            let maxCount = 0;
            for (const [tag, count] of Object.entries(tagCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    maxTag = tag;
                }
            }
            
            return maxTag;
        }
        
        // ============================================================================
        // CONFIRM MATCH IMPORT
        // ============================================================================
        async function confirmMatchImport() {
            if (!pendingMatchImport) return;
            
            const { matchInfo, players, noShows, mvp, friendlyPlayers, pairings } = pendingMatchImport;
            
            // --- DUPLICATE DETECTION ---
            try {
                const { data: existing } = await HLL.supabase
                    .from('matches')
                    .select('match_id, match_date, map, enemy_team, my_score, enemy_score')
                    .eq('match_date', matchInfo.date)
                    .eq('map', matchInfo.map || 'Unknown')
                    .eq('my_score', matchInfo.myScore)
                    .eq('enemy_score', matchInfo.enemyScore);
                
                if (existing && existing.length > 0) {
                    const dupMatch = existing[0];
                    const proceed = confirm(
                        `‚ö†Ô∏è Possible duplicate detected!\n\n` +
                        `Existing match: ${dupMatch.match_id}\n` +
                        `Date: ${dupMatch.match_date}\n` +
                        `Map: ${dupMatch.map}\n` +
                        `vs ${dupMatch.enemy_team} (${dupMatch.my_score}-${dupMatch.enemy_score})\n\n` +
                        `Do you still want to import this match?`
                    );
                    if (!proceed) {
                        HLL.hideLoading();
                        return;
                    }
                }
            } catch (dupErr) {
                console.warn('Duplicate check failed, proceeding:', dupErr);
            }
            
            HLL.showLoading('Importing match...');
            
            try {
                // --- PRE-STEP: Apply SteamID pairings for TEMP players ---
                if (pairings && pairings.length > 0) {
                    for (let i = 0; i < pairings.length; i++) {
                        const p = pairings[i];
                        const checkbox = document.getElementById(`pairing-${i}`);
                        if (checkbox && checkbox.checked) {
                            // Insert new row with real SteamID, copy data from temp
                            const { data: tempPlayer } = await HLL.supabase
                                .from('players')
                                .select('*')
                                .eq('steam_id', p.tempId)
                                .single();
                            
                            if (tempPlayer) {
                                // Create player with real SteamID
                                const newPlayer = { ...tempPlayer, steam_id: p.realSteamId };
                                delete newPlayer.created_at;
                                delete newPlayer.updated_at;
                                
                                const { error: insertErr } = await HLL.supabase
                                    .from('players')
                                    .insert(newPlayer);
                                
                                if (!insertErr) {
                                    // Delete temp entry
                                    await HLL.supabase
                                        .from('players')
                                        .delete()
                                        .eq('steam_id', p.tempId);
                                    
                                    console.log(`Paired ${p.playerName}: ${p.tempId} ‚Üí ${p.realSteamId}`);
                                } else {
                                    console.warn(`Failed to pair ${p.playerName}:`, insertErr);
                                }
                            }
                        }
                    }
                }
                
                // --- Read my team from editable input ---
                const myTeamInput = document.getElementById('myTeamInput');
                const myTeam = myTeamInput ? myTeamInput.value.trim() || HLL.currentTeam || 'Circle' : HLL.currentTeam || 'Circle';
                
                // --- Read enemy team from editable input (user may have corrected it) ---
                const enemyTeamInput = document.getElementById('enemyTeamInput');
                if (enemyTeamInput) {
                    matchInfo.enemyTeam = enemyTeamInput.value.trim() || matchInfo.enemyTeam || 'Unknown';
                }
                
                // --- 0. AUTO-ADD NEW FRIENDLY PLAYERS TO ROSTER (must be before match insert for FK) ---
                await autoAddNewPlayers(friendlyPlayers, matchInfo, myTeam);
                
                // Generate match ID (MTH-XXXXXX format, sequential)
                const matchId = await generateMatchId();
                
                const matchTypeInput = document.getElementById('matchTypeInput');
                const matchType = matchTypeInput ? matchTypeInput.value : (window._pendingMatchType || 'Friendly');
                
                // --- 1. INSERT MATCH (Match_Log equivalent) ---
                const { error: matchError } = await HLL.supabase
                    .from('matches')
                    .insert({
                        match_id: matchId,
                        match_date: matchInfo.date,
                        my_team: myTeam,
                        enemy_team: matchInfo.enemyTeam || 'Unknown',
                        my_faction: matchInfo.myFaction || 'Allies',
                        enemy_faction: matchInfo.enemyFaction || 'Axis',
                        map: matchInfo.map || 'Unknown',
                        result: matchInfo.result || 'D',
                        my_score: matchInfo.myScore,
                        enemy_score: matchInfo.enemyScore,
                        duration: matchInfo.duration,
                        mvp_steam_id: mvp ? mvp.steamId : null,
                        mvp_name: mvp ? mvp.name : null,
                        match_type: matchType
                    });
                if (matchError) throw matchError;
                
                // --- 2. INSERT MATCH_DETAILS (all players, all stats) ---
                const details = players.map(p => ({
                    match_id: matchId,
                    steam_id: p.steamId,
                    player_name: p.name,
                    faction: p.faction,
                    team: p.isFriendly ? 'Friendly' : 'Enemy',
                    role: p.role || null,
                    kills: p.kills,
                    deaths: p.deaths,
                    kd: p.kd,
                    max_kill_streak: p.maxKillStreak,
                    kpm: p.kpm,
                    dpm: p.dpm,
                    max_death_streak: p.maxDeathStreak,
                    max_tk_streak: p.maxTkStreak,
                    death_by_tk: p.deathByTk,
                    longest_life_min: p.longestLifeMin,
                    shortest_life_sec: p.shortestLifeSec,
                    combat_eff: p.ce,
                    support_pts: p.support,
                    defensive_pts: p.defensive,
                    offensive_pts: p.offensive
                }));
                
                const { error: detailsError } = await HLL.supabase
                    .from('match_details')
                    .insert(details);
                if (detailsError) throw detailsError;
                
                // --- 3. INSERT MATCH_LINEUPS (friendly players with roles) ---
                const lineupRows = friendlyPlayers
                    .filter(p => p.role)
                    .map(p => ({
                        match_id: matchId,
                        role: p.role,
                        player_name: p.name,
                        steam_id: p.steamId,
                        cell_position: p.cell_position || null,
                        section: p.section || null,
                        sl_role: p.sl_role || null,
                        note: p.note || null
                    }));
                
                if (lineupRows.length > 0) {
                    const { error: lineupError } = await HLL.supabase
                        .from('match_lineups')
                        .insert(lineupRows);
                    if (lineupError) throw lineupError;
                }
                
                // --- 4. INSERT NO_SHOWS ---
                if (noShows.length > 0) {
                    const noShowRows = noShows
                        .filter(ns => ns.steamId) // Need steam_id for FK
                        .map(ns => ({
                            match_id: matchId,
                            steam_id: ns.steamId,
                            player_name: ns.playerName,
                            match_date: matchInfo.date,
                            excused: false
                        }));
                    
                    if (noShowRows.length > 0) {
                        const { error: noShowError } = await HLL.supabase
                            .from('no_shows')
                            .insert(noShowRows);
                        if (noShowError) {
                            console.warn('No-show insert warning:', noShowError);
                            // Non-critical, don't block import
                        }
                    }
                }
                
                // --- 5. UPDATE PLAYER STATS (via DB function) ---
                try {
                    await HLL.supabase.rpc('update_player_stats_from_match', { p_match_id: matchId });
                } catch (rpcErr) {
                    console.warn('Player stats update warning:', rpcErr);
                    // Non-critical ‚Äî stats can be recalculated later
                }
                
                // --- 6. UPDATE ENEMY INTEL ---
                try {
                    await updateEnemyIntel(matchInfo, players);
                } catch (enemyErr) {
                    console.warn('Enemy intel update warning:', enemyErr);
                    // Non-critical ‚Äî doesn't block import
                }
                
                HLL.hideLoading();
                
                const resultText = matchInfo.result === 'W' ? 'WIN' : matchInfo.result === 'L' ? 'LOSS' : 'DRAW';
                HLL.showAlert(
                    `Match imported: ${matchId}\n` +
                    `${matchInfo.map} ‚Äî ${matchInfo.myScore}:${matchInfo.enemyScore} (${resultText})\n` +
                    `${friendlyPlayers.length} friendly, ${players.length - friendlyPlayers.length} enemy\n` +
                    `${noShows.length} no-show(s)` +
                    (mvp ? `\nMVP: ${mvp.name} (CE: ${mvp.ce})` : ''),
                    'success'
                );
                cancelMatchImport();
                
            } catch (err) {
                console.error('Match import error:', err);
                HLL.hideLoading();
                HLL.showAlert('Import failed: ' + err.message, 'error');
            }
        }
        
        /**
         * Generate sequential match ID (MTH-000001, MTH-000002, ...).
         * Mirrors VBA GenerateMatchID (line 867).
         */
        async function generateMatchId() {
            const { data, error } = await HLL.supabase
                .from('matches')
                .select('match_id')
                .order('match_id', { ascending: false })
                .limit(1);
            
            let num = 1;
            if (!error && data && data.length > 0) {
                const lastId = data[0].match_id; // e.g., "MTH-000005"
                const lastNum = parseInt(lastId.replace('MTH-', ''), 10);
                if (!isNaN(lastNum)) num = lastNum + 1;
            }
            
            return 'MTH-' + String(num).padStart(6, '0');
        }
        
        /**
         * Auto-add new friendly players to roster if not already present.
         * Mirrors VBA UpdateRosterStats new player logic (line 1064).
         */
        async function autoAddNewPlayers(friendlyPlayers, matchInfo, myTeam) {
            if (!friendlyPlayers.length) return;
            
            // Get existing roster with names and previous_names
            const { data: existing } = await HLL.supabase
                .from('players')
                .select('steam_id, name, previous_names');
            
            const rosterMap = {};
            (existing || []).forEach(p => { rosterMap[p.steam_id] = p; });
            
            const newPlayers = [];
            const nameChanges = [];
            
            for (const p of friendlyPlayers) {
                if (!p.steamId) continue;
                
                const rosterPlayer = rosterMap[p.steamId];
                if (!rosterPlayer) {
                    // NEW PLAYER ‚Äî check if a per-player team was assigned in the preview
                    const playerTeamSelect = document.querySelector(`.new-player-team[data-steamid="${p.steamId}"]`);
                    const assignedTeam = playerTeamSelect ? playerTeamSelect.value : (myTeam || HLL.currentTeam || 'Circle');
                    
                    newPlayers.push({
                        steam_id: p.steamId,
                        name: stripClanTag(p.name),
                        team: assignedTeam,
                        first_seen: matchInfo.date,
                        last_seen: matchInfo.date
                    });
                } else {
                    // EXISTING PLAYER ‚Äî check for name change (compare stripped names)
                    const oldName = (rosterPlayer.name || '').trim();
                    const newName = stripClanTag(p.name);
                    const normalize = s => (s || '').replace(/[^a-z0-9]/gi, '').toLowerCase();
                    
                    if (normalize(oldName) !== normalize(newName) && newName.length > 0) {
                        // Name changed ‚Äî append old name to previous_names array
                        const prevNames = rosterPlayer.previous_names || [];
                        const prevLower = prevNames.map(n => normalize(n));
                        
                        // Only add old name if not already tracked
                        if (!prevLower.includes(normalize(oldName))) {
                            prevNames.push(oldName);
                        }
                        
                        nameChanges.push({
                            steamId: p.steamId,
                            newName: newName,
                            prevNames: prevNames
                        });
                    }
                }
            }
            
            // Insert new players
            if (newPlayers.length > 0) {
                const { error } = await HLL.supabase
                    .from('players')
                    .upsert(newPlayers, { onConflict: 'steam_id', ignoreDuplicates: true });
                
                if (error) console.warn('Auto-add players warning:', error);
                else console.log(`Auto-added ${newPlayers.length} new player(s) to roster`);
            }
            
            // Update name changes
            for (const nc of nameChanges) {
                const { error } = await HLL.supabase
                    .from('players')
                    .update({ name: nc.newName, previous_names: nc.prevNames })
                    .eq('steam_id', nc.steamId);
                
                if (error) console.warn(`Name change update failed for ${nc.steamId}:`, error);
                else console.log(`Name change: ${nc.prevNames[nc.prevNames.length - 1]} ‚Üí ${nc.newName}`);
            }
            
            if (nameChanges.length > 0) {
                console.log(`Tracked ${nameChanges.length} name change(s)`);
            }
        }
        
        /**
         * Strip clan tag prefix from player name.
         * Handles: "‚óØ | Name", "„Äá I Name", "[TAG] Name", "TAG | Name"
         * Only strips the FIRST recognized prefix, not nested tags.
         */
        function stripClanTag(name) {
            if (!name) return name;
            let stripped = name.trim();
            // Remove "‚óØ | " or "„Äá I " or similar circle-pipe prefix
            if (/^[‚óØ„Äá‚óã‚≠ï]\s*[|I]\s*/i.test(stripped)) {
                return stripped.replace(/^[‚óØ„Äá‚óã‚≠ï]\s*[|I]\s*/i, '').trim();
            }
            // Remove "[TAG] " prefix (square bracket tags)
            if (/^\[[^\]]{1,10}\]\s*/.test(stripped)) {
                return stripped.replace(/^\[[^\]]{1,10}\]\s*/, '').trim();
            }
            // Remove "TAG | " prefix (2-10 char tag with pipe)
            if (/^[A-Za-z0-9]{2,10}\s*\|\s*/.test(stripped)) {
                return stripped.replace(/^[A-Za-z0-9]{2,10}\s*\|\s*/, '').trim();
            }
            return stripped;
        }
        
        // ============================================================================
        // UPDATE ENEMY INTEL
        // Registers/updates enemy team and all enemy players after match import.
        // Tracks which teams each player has played for (mercenary detection).
        // ============================================================================
        async function updateEnemyIntel(matchInfo, players) {
            const enemyTag = matchInfo.enemyTeam || 'Unknown';
            const matchDate = matchInfo.date || new Date().toISOString().split('T')[0];
            const enemyPlayers = players.filter(p => !p.isFriendly);
            
            if (enemyPlayers.length === 0) return;
            
            // --- 6a. Upsert enemy team ---
            const { error: teamErr } = await HLL.supabase
                .from('enemy_teams')
                .upsert({
                    tag: enemyTag,
                    first_seen: matchDate,
                    last_seen: matchDate,
                    updated_at: new Date().toISOString()
                }, { 
                    onConflict: 'tag',
                    ignoreDuplicates: false 
                });
            
            // Update last_seen if team already exists (upsert may not handle this correctly)
            if (!teamErr) {
                await HLL.supabase
                    .from('enemy_teams')
                    .update({ last_seen: matchDate, updated_at: new Date().toISOString() })
                    .eq('tag', enemyTag)
                    .lt('last_seen', matchDate);
            }
            
            if (teamErr) console.warn('Enemy team upsert warning:', teamErr);
            else console.log(`[enemyIntel] Registered enemy team: [${enemyTag}]`);
            
            // --- 6b. Upsert enemy players ---
            const playerRows = enemyPlayers.map(p => ({
                steam_id: p.steamId,
                name: p.name,
                primary_team_tag: enemyTag,
                first_seen: matchDate,
                last_seen: matchDate,
                updated_at: new Date().toISOString()
            }));
            
            // Insert new, skip existing (we'll update separately)
            const { error: playersErr } = await HLL.supabase
                .from('enemy_players')
                .upsert(playerRows, { 
                    onConflict: 'steam_id',
                    ignoreDuplicates: false 
                });
            
            if (playersErr) console.warn('Enemy players upsert warning:', playersErr);
            else console.log(`[enemyIntel] Registered ${playerRows.length} enemy players`);
            
            // --- 6c. Track team affiliations (mercenary detection) ---
            for (const ep of enemyPlayers) {
                // Check if this player-team combo exists
                const { data: existing } = await HLL.supabase
                    .from('enemy_player_teams')
                    .select('id, match_count')
                    .eq('steam_id', ep.steamId)
                    .eq('team_tag', enemyTag)
                    .single();
                
                if (existing) {
                    // Increment match count, update last_seen
                    await HLL.supabase
                        .from('enemy_player_teams')
                        .update({ 
                            match_count: existing.match_count + 1,
                            last_seen: matchDate
                        })
                        .eq('id', existing.id);
                } else {
                    // New team affiliation
                    await HLL.supabase
                        .from('enemy_player_teams')
                        .insert({
                            steam_id: ep.steamId,
                            team_tag: enemyTag,
                            match_count: 1,
                            first_seen: matchDate,
                            last_seen: matchDate
                        });
                }
            }
            
            // --- 6d. Update primary_team_tag for players with multiple teams ---
            // Primary = team with most matches
            const uniqueSteamIds = [...new Set(enemyPlayers.map(p => p.steamId))];
            for (const sid of uniqueSteamIds) {
                const { data: teamAffils } = await HLL.supabase
                    .from('enemy_player_teams')
                    .select('team_tag, match_count')
                    .eq('steam_id', sid)
                    .order('match_count', { ascending: false })
                    .limit(1);
                
                if (teamAffils && teamAffils.length > 0) {
                    await HLL.supabase
                        .from('enemy_players')
                        .update({ primary_team_tag: teamAffils[0].team_tag })
                        .eq('steam_id', sid);
                }
            }
            
            console.log(`[enemyIntel] Enemy intel updated for [${enemyTag}]: ${enemyPlayers.length} players`);
        }
        
        function cancelMatchImport() {
            pendingMatchImport = null;
            document.getElementById('matchPreviewCard').classList.add('hidden');
            document.getElementById('teamPasteData').value = '';
            document.getElementById('csvFileInput').value = '';
        }
        
        // ============================================================================
        // DATABASE TOOLS
        // ============================================================================
        
        async function recalculateStats() {
            if (!HLL.confirm('This will recalculate all player statistics from match history. Continue?')) {
                return;
            }
            
            HLL.showLoading('Recalculating stats...');
            
            // This would call a Supabase function or do client-side recalculation
            // For now, just show a message
            
            setTimeout(() => {
                HLL.hideLoading();
                HLL.showAlert('Stats recalculation not yet implemented', 'warning');
            }, 1000);
        }
        
        // ============================================================================
        // BACKUP SYSTEM
        // ============================================================================
        
        const BACKUP_TABLES = [
            'players', 'matches', 'match_details', 'match_lineups', 
            'no_shows', 'enemy_teams', 'enemy_team_divisions', 
            'divisions', 'my_team_divisions', 'lineups'
        ];
        
        async function fetchAllTables() {
            const data = {};
            for (const table of BACKUP_TABLES) {
                try {
                    const { data: rows, error } = await HLL.supabase.from(table).select('*');
                    if (error) {
                        console.warn(`Skipping ${table}: ${error.message}`);
                        continue;
                    }
                    data[table] = rows || [];
                } catch (e) {
                    console.warn(`Skipping ${table}: ${e.message}`);
                }
            }
            return data;
        }
        
        function tableToCsv(rows) {
            if (!rows || rows.length === 0) return '';
            const headers = Object.keys(rows[0]);
            const csvRows = [headers.join(',')];
            rows.forEach(row => {
                csvRows.push(headers.map(h => {
                    let val = row[h];
                    if (val === null || val === undefined) return '';
                    val = String(val).replace(/"/g, '""');
                    if (val.includes(',') || val.includes('"') || val.includes('\n')) {
                        val = `"${val}"`;
                    }
                    return val;
                }).join(','));
            });
            return csvRows.join('\n');
        }
        
        async function exportBackup(format) {
            HLL.showLoading('Creating backup...');
            
            try {
                const allData = await fetchAllTables();
                const dateStr = new Date().toISOString().split('T')[0];
                const tableCount = Object.keys(allData).length;
                const rowCount = Object.values(allData).reduce((s, rows) => s + rows.length, 0);
                
                if (format === 'json') {
                    // Single JSON file with all tables
                    const exportData = {
                        backup_type: 'full',
                        exported_at: new Date().toISOString(),
                        tables: allData,
                        meta: { tableCount, rowCount }
                    };
                    downloadFile(
                        JSON.stringify(exportData, null, 2),
                        `HLL_Backup_${dateStr}.json`,
                        'application/json'
                    );
                    HLL.hideLoading();
                    HLL.showAlert(`Backup complete: ${tableCount} tables, ${rowCount} rows`, 'success');
                    
                } else if (format === 'csv') {
                    // Zip of CSV files (one per table)
                    await exportCsvZip(allData, dateStr, tableCount, rowCount);
                    
                } else if (format === 'both') {
                    // Zip containing JSON + all CSVs
                    await exportBothZip(allData, dateStr, tableCount, rowCount);
                }
                
            } catch (err) {
                console.error('Backup error:', err);
                HLL.hideLoading();
                HLL.showAlert('Backup failed: ' + err.message, 'error');
            }
        }
        
        async function exportCsvZip(allData, dateStr, tableCount, rowCount) {
            // Load JSZip
            if (!window.JSZip) {
                await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js');
            }
            const zip = new JSZip();
            const folder = zip.folder(`HLL_Backup_${dateStr}`);
            
            for (const [table, rows] of Object.entries(allData)) {
                if (rows.length > 0) {
                    folder.file(`${table}.csv`, tableToCsv(rows));
                }
            }
            
            const blob = await zip.generateAsync({ type: 'blob' });
            downloadBlob(blob, `HLL_Backup_CSV_${dateStr}.zip`);
            HLL.hideLoading();
            HLL.showAlert(`CSV backup: ${tableCount} tables, ${rowCount} rows`, 'success');
        }
        
        async function exportBothZip(allData, dateStr, tableCount, rowCount) {
            if (!window.JSZip) {
                await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js');
            }
            const zip = new JSZip();
            const folder = zip.folder(`HLL_Backup_${dateStr}`);
            
            // JSON
            const exportData = {
                backup_type: 'full',
                exported_at: new Date().toISOString(),
                tables: allData,
                meta: { tableCount, rowCount }
            };
            folder.file('backup.json', JSON.stringify(exportData, null, 2));
            
            // CSVs
            const csvFolder = folder.folder('csv');
            for (const [table, rows] of Object.entries(allData)) {
                if (rows.length > 0) {
                    csvFolder.file(`${table}.csv`, tableToCsv(rows));
                }
            }
            
            const blob = await zip.generateAsync({ type: 'blob' });
            downloadBlob(blob, `HLL_Backup_Full_${dateStr}.zip`);
            HLL.hideLoading();
            HLL.showAlert(`Full backup: ${tableCount} tables, ${rowCount} rows (JSON + CSV)`, 'success');
        }
        
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            downloadBlob(blob, filename);
        }
        
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                document.head.appendChild(s);
            });
        }
        
        async function clearAllLineups() {
            if (!HLL.confirm('This will remove ALL lineup assignments. This cannot be undone. Continue?')) {
                return;
            }
            
            HLL.showLoading('Clearing lineups...');
            
            try {
                const { error } = await HLL.supabase
                    .from('lineups')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000'); // Delete all
                
                if (error) throw error;
                
                HLL.hideLoading();
                HLL.showAlert('All lineups cleared', 'success');
                
            } catch (err) {
                console.error('Clear error:', err);
                HLL.hideLoading();
                HLL.showAlert('Failed to clear lineups', 'error');
            }
        }
        
        // ============================================================================
        // MATCH TYPE SELECTION POPUP
        // ============================================================================
        async function selectMatchType() {
            // Load divisions
            let divOptions = [];
            try {
                const { data } = await HLL.supabase
                    .from('divisions')
                    .select('*')
                    .order('sort_order', { ascending: true });
                divOptions = data || [];
            } catch (e) { console.warn('Could not load divisions:', e); }

            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:1000;display:flex;align-items:center;justify-content:center;';

                const modal = document.createElement('div');
                modal.style.cssText = 'background:var(--bg-secondary,#1a1a2e);border-radius:8px;padding:24px;min-width:320px;max-width:400px;max-height:80vh;overflow-y:auto;';

                const options = [
                    { name: 'Friendly', style: '' },
                    ...divOptions.map(d => ({ name: d.name, style: '' }))
                ];

                modal.innerHTML = `
                    <h3 style="margin:0 0 4px;font-size:1.1rem;">Select Match Type</h3>
                    <p style="font-size:0.8rem;color:var(--text-secondary);margin:0 0 16px;">What type of match is this?</p>
                    <div style="display:flex;flex-direction:column;gap:6px;">
                        ${options.map(o => `
                            <button class="btn btn-secondary" style="text-align:left;padding:10px 14px;font-size:0.9rem;" 
                                onclick="this.closest('div[style*=fixed]').remove()">
                                ${o.name === 'Friendly' ? 'ü§ù' : 'üèÜ'} ${o.name}
                            </button>
                        `).join('')}
                    </div>
                    <div style="margin-top:12px;text-align:center;">
                        <button class="btn btn-sm" style="padding:6px 16px;opacity:0.6;" 
                            onclick="this.closest('div[style*=fixed]').remove()">Cancel</button>
                    </div>
                `;

                // Attach click handlers to each option button
                overlay.appendChild(modal);
                document.body.appendChild(overlay);

                const buttons = modal.querySelectorAll('.btn-secondary');
                buttons.forEach((btn, i) => {
                    btn.onclick = () => {
                        overlay.remove();
                        resolve(options[i].name);
                    };
                });

                // Cancel button
                modal.querySelector('.btn-sm').onclick = () => {
                    overlay.remove();
                    resolve(null);
                };
            });
        }

        // ============================================================================
        // MY TEAM DIVISIONS
        // ============================================================================
        async function loadMyTeamDivisions() {
            const container = document.getElementById('myTeamDivisionsContainer');
            if (!container) return;
            
            const myTeam = HLL.currentTeam || 'Circle';
            
            const { data: allDivs } = await HLL.supabase
                .from('divisions')
                .select('*')
                .order('sort_order', { ascending: true });
            
            const { data: myDivs } = await HLL.supabase
                .from('my_team_divisions')
                .select('division_id')
                .eq('team_name', myTeam);
            
            const myDivIds = new Set((myDivs || []).map(d => d.division_id));
            const activeDivs = (allDivs || []).filter(d => myDivIds.has(d.id));
            
            if (activeDivs.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); font-size: 0.85rem;">No divisions set. Click Edit to add.</div>';
            } else {
                container.innerHTML = '<div style="display: flex; flex-wrap: wrap; gap: 6px;">' +
                    activeDivs.map(d => `<span style="display: inline-block; padding: 3px 10px; border-radius: 4px; font-size: 0.8rem; background: rgba(255,152,0,0.15); color: #ff9800;">${d.name}</span>`).join('') +
                    '</div>';
            }
        }

        async function openMyTeamDivisionPicker() {
            const myTeam = HLL.currentTeam || 'Circle';
            
            const { data: allDivs } = await HLL.supabase
                .from('divisions')
                .select('*')
                .order('sort_order', { ascending: true });
            
            const { data: myDivs } = await HLL.supabase
                .from('my_team_divisions')
                .select('division_id')
                .eq('team_name', myTeam);
            
            const myDivIds = new Set((myDivs || []).map(d => d.division_id));
            
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:1000;display:flex;align-items:center;justify-content:center;';
            overlay.onclick = (e) => { if (e.target === overlay) { overlay.remove(); loadMyTeamDivisions(); } };
            
            const modal = document.createElement('div');
            modal.style.cssText = 'background:var(--bg-secondary,#1a1a2e);border-radius:8px;padding:20px;min-width:320px;max-width:450px;max-height:80vh;overflow-y:auto;';
            modal.innerHTML = `
                <h3 style="margin:0 0 4px;font-size:1rem;">Divisions for ${myTeam}</h3>
                <p style="font-size:0.8rem;color:var(--text-secondary);margin:0 0 12px;">Select the leagues/divisions your team plays in.</p>
                <div id="myDivCheckboxes">
                    ${(allDivs || []).map(d => `
                        <div style="display:flex;align-items:center;gap:8px;padding:6px 0;cursor:pointer;">
                            <input type="checkbox" id="mydiv_${d.id}" ${myDivIds.has(d.id) ? 'checked' : ''}
                                onchange="toggleMyTeamDivision('${myTeam}', '${d.id}', this.checked)"
                                style="accent-color:#ff9800;">
                            <label for="mydiv_${d.id}" style="cursor:pointer;flex:1;">${d.name}</label>
                        </div>
                    `).join('')}
                </div>
                <div style="margin-top:12px;text-align:right;">
                    <button class="btn btn-sm" onclick="this.closest('div[style*=fixed]').remove(); loadMyTeamDivisions();" style="padding:6px 16px;">Done</button>
                </div>
            `;
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }

        async function toggleMyTeamDivision(teamName, divisionId, checked) {
            if (checked) {
                await HLL.supabase
                    .from('my_team_divisions')
                    .insert({ team_name: teamName, division_id: divisionId });
            } else {
                await HLL.supabase
                    .from('my_team_divisions')
                    .delete()
                    .eq('team_name', teamName)
                    .eq('division_id', divisionId);
            }
        }

        // ===================== MANAGE TEAMS =====================

        async function loadManagedTeams() {
            // My Teams: distinct team values from players table + my_team from matches
            const myTeamsSet = new Set();
            const { data: players } = await HLL.supabase.from('players').select('team');
            if (players) players.forEach(p => { if (p.team) myTeamsSet.add(p.team); });
            const { data: matches } = await HLL.supabase.from('matches').select('my_team');
            if (matches) matches.forEach(m => { if (m.my_team) myTeamsSet.add(m.my_team); });
            
            // Count players and matches per team
            const playerCounts = {};
            const matchCounts = {};
            if (players) players.forEach(p => { if (p.team) playerCounts[p.team] = (playerCounts[p.team] || 0) + 1; });
            if (matches) matches.forEach(m => { if (m.my_team) matchCounts[m.my_team] = (matchCounts[m.my_team] || 0) + 1; });
            
            const myTeams = [...myTeamsSet].sort();
            const myList = document.getElementById('myTeamsList');
            if (myTeams.length === 0) {
                myList.innerHTML = '<div style="color: var(--text-secondary); font-size: 0.8rem;">No teams yet</div>';
            } else {
                myList.innerHTML = myTeams.map(t => {
                    const pc = playerCounts[t] || 0;
                    const mc = matchCounts[t] || 0;
                    const isEmpty = pc === 0 && mc === 0;
                    const escaped = t.replace(/'/g, "\\'");
                    return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 3px 0; border-bottom: 1px solid rgba(255,255,255,0.05);">
                        <div style="display:flex;align-items:center;gap:6px;">
                            <span style="font-size: 0.85rem;">${t}</span>
                            <span style="font-size:10px;color:var(--text-secondary);">(${pc}p, ${mc}m)</span>
                        </div>
                        <div style="display:flex;gap:2px;">
                            <button onclick="renameMyTeam('${escaped}')" 
                                style="background: none; border: none; color: var(--accent-orange); cursor: pointer; font-size: 11px; padding: 2px 6px;" title="Migrate players / Rename">‚úèÔ∏è</button>
                            <button onclick="deleteMyTeam('${escaped}')" 
                                style="background: none; border: none; color: #f87171; cursor: pointer; font-size: 11px; padding: 2px 6px;" title="Delete">‚úï</button>
                        </div>
                    </div>`;
                }).join('');
            }
            
            // Enemy Teams: from enemy_teams table + distinct enemy_team from matches
            const enemyTeamsSet = new Set();
            const { data: enemyTeams } = await HLL.supabase.from('enemy_teams').select('team_tag');
            if (enemyTeams) enemyTeams.forEach(t => { if (t.team_tag) enemyTeamsSet.add(t.team_tag); });
            const { data: matches2 } = await HLL.supabase.from('matches').select('enemy_team');
            if (matches2) matches2.forEach(m => { if (m.enemy_team) enemyTeamsSet.add(m.enemy_team); });
            
            const allEnemy = [...enemyTeamsSet].sort();
            const enemyList = document.getElementById('enemyTeamsList');
            if (allEnemy.length === 0) {
                enemyList.innerHTML = '<div style="color: var(--text-secondary); font-size: 0.8rem;">No teams yet</div>';
            } else {
                // Track which are in enemy_teams table vs only in matches
                const inTable = new Set((enemyTeams || []).map(t => t.team_tag));
                enemyList.innerHTML = allEnemy.map(t => `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 3px 0; border-bottom: 1px solid rgba(255,255,255,0.05); gap: 4px;">
                        <span style="font-size: 0.85rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: 0;">${t} ${!inTable.has(t) ? '<span style="font-size:10px;color:var(--text-secondary);">(matches)</span>' : ''}</span>
                        <button onclick="removeEnemyTeam('${t.replace(/'/g, "\\'")}')" 
                            style="background: none; border: none; color: #f87171; cursor: pointer; font-size: 11px; padding: 2px 6px; flex-shrink: 0;" title="Remove">‚úï</button>
                    </div>
                `).join('');
            }
        }

        async function addMyTeam() {
            const input = document.getElementById('addMyTeamInput');
            const name = input.value.trim();
            if (!name) return;
            // Add a placeholder player entry to register the team, or just note it
            // For now, we add it via a dummy roster entry check ‚Äî but simpler: just insert a player with no steam_id
            // Actually, my_team comes from players.team ‚Äî we can't add without a player.
            // Better approach: just inform user that my teams come from roster entries.
            HLL.showAlert('My Teams are populated from your player roster. Add a player with this team name to register it.', 'info');
            input.value = '';
        }

        async function addEnemyTeam() {
            const input = document.getElementById('addEnemyTeamInput');
            const tag = input.value.trim();
            if (!tag) return;
            
            // Check if already exists
            const { data: existing } = await HLL.supabase.from('enemy_teams').select('team_tag').eq('team_tag', tag);
            if (existing && existing.length > 0) {
                HLL.showAlert(`"${tag}" already exists`, 'error');
                return;
            }
            
            const { error } = await HLL.supabase.from('enemy_teams').insert({ team_tag: tag });
            if (error) {
                HLL.showAlert('Failed to add team: ' + error.message, 'error');
            } else {
                HLL.showAlert(`Added "${tag}"`, 'success');
                input.value = '';
                loadManagedTeams();
            }
        }

        async function renameMyTeam(oldName) {
            // Fetch players and matches using this team
            const { data: playersUsing, error: pErr } = await HLL.supabase.from('players').select('steam_id, player_name').eq('team', String(oldName)).order('player_name');
            const { data: matchesUsing, error: mErr } = await HLL.supabase.from('matches').select('match_id').eq('my_team', String(oldName));
            if (pErr) console.warn('Player query error:', pErr);
            if (mErr) console.warn('Match query error:', mErr);
            console.log(`[renameMyTeam] "${oldName}" ‚Üí ${playersUsing?.length || 0} players, ${matchesUsing?.length || 0} matches`, playersUsing);
            const playerCount = playersUsing?.length || 0;
            const matchCount = matchesUsing?.length || 0;
            
            // Get all known team names for destination dropdown
            const teamSet = new Set();
            const { data: allPlayers } = await HLL.supabase.from('players').select('team');
            if (allPlayers) allPlayers.forEach(p => { if (p.team) teamSet.add(p.team); });
            const { data: allMatches } = await HLL.supabase.from('matches').select('my_team');
            if (allMatches) allMatches.forEach(m => { if (m.my_team) teamSet.add(m.my_team); });
            teamSet.delete(oldName); // Don't show current team as destination
            const destTeams = [...teamSet].sort();
            
            // Build modal
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:1000;display:flex;align-items:center;justify-content:center;';
            overlay.id = 'teamEditOverlay';
            
            const modal = document.createElement('div');
            modal.style.cssText = 'background:var(--bg-secondary,#1a1a2e);border-radius:8px;padding:24px;min-width:400px;max-width:500px;max-height:80vh;overflow-y:auto;';
            
            modal.innerHTML = `
                <h3 style="margin:0 0 4px;font-size:1.1rem;">Edit Team: "${oldName}"</h3>
                <p style="font-size:0.8rem;color:var(--text-secondary);margin:0 0 16px;">${playerCount} player(s), ${matchCount} match(es)</p>
                
                <div style="margin-bottom: 16px;">
                    <label style="font-size:0.85rem;font-weight:600;display:block;margin-bottom:4px;">Move to:</label>
                    <div style="display:flex;gap:6px;">
                        <select id="teamEditDest" style="flex:1;padding:6px 8px;font-size:0.85rem;background:var(--bg-input,#1a1a2e);border:1px solid var(--border-color);border-radius:4px;color:var(--text-primary);">
                            ${destTeams.map(t => `<option value="${t}">${t}</option>`).join('')}
                            <option value="__custom__">+ New team name...</option>
                        </select>
                    </div>
                </div>
                
                <div style="margin-bottom: 12px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                        <label style="font-size:0.85rem;font-weight:600;">Players (${playerCount}):</label>
                        ${playerCount > 0 ? `
                        <div style="display:flex;gap:8px;">
                            <button onclick="document.querySelectorAll('.team-edit-cb').forEach(c=>c.checked=true)" 
                                style="background:none;border:none;color:var(--accent-orange);cursor:pointer;font-size:11px;">Select all</button>
                            <button onclick="document.querySelectorAll('.team-edit-cb').forEach(c=>c.checked=false)" 
                                style="background:none;border:none;color:var(--text-secondary);cursor:pointer;font-size:11px;">Deselect all</button>
                        </div>
                        ` : ''}
                    </div>
                    <div style="max-height:250px;overflow-y:auto;border:1px solid rgba(255,255,255,0.05);border-radius:4px;padding:4px;">
                        ${playerCount > 0 ? playersUsing.map(p => `
                            <label style="display:flex;align-items:center;gap:8px;padding:4px 6px;font-size:0.85rem;cursor:pointer;">
                                <input type="checkbox" class="team-edit-cb" value="${p.steam_id}" checked>
                                <span>${p.player_name || p.steam_id}</span>
                                <span style="font-size:10px;color:var(--text-secondary);margin-left:auto;">${p.steam_id}</span>
                            </label>
                        `).join('') : '<div style="color:var(--text-secondary);font-size:0.8rem;padding:8px;">No players found with this team value. It may exist only in match records.</div>'}
                    </div>
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display:flex;align-items:center;gap:8px;font-size:0.85rem;cursor:pointer;">
                        <input type="checkbox" id="teamEditMatches" checked>
                        Also update ${matchCount} match record(s) from "${oldName}"
                    </label>
                </div>
                
                <div style="display:flex;gap:8px;justify-content:flex-end;">
                    <button class="btn btn-sm" onclick="document.getElementById('teamEditOverlay').remove()" 
                        style="padding:6px 16px;opacity:0.6;">Cancel</button>
                    <button class="btn btn-primary btn-sm" id="teamEditConfirm" style="padding:6px 16px;">Apply</button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Handle custom team name in dropdown
            const destSelect = document.getElementById('teamEditDest');
            destSelect.addEventListener('change', function() {
                if (this.value === '__custom__') {
                    const v = prompt('Enter new team name:');
                    if (v && v.trim()) {
                        const o = document.createElement('option');
                        o.value = v.trim();
                        o.textContent = v.trim();
                        this.insertBefore(o, this.lastElementChild);
                        this.value = v.trim();
                    } else {
                        this.value = destTeams[0] || '';
                    }
                }
            });
            
            // Confirm handler
            document.getElementById('teamEditConfirm').onclick = async function() {
                const dest = destSelect.value;
                if (!dest || dest === '__custom__') {
                    HLL.showAlert('Please select a destination team', 'error');
                    return;
                }
                
                // Get selected players with names
                const checkboxes = document.querySelectorAll('.team-edit-cb:checked');
                const selectedIds = [...checkboxes].map(cb => cb.value);
                const selectedNames = [...checkboxes].map(cb => {
                    const label = cb.closest('label');
                    return label ? label.querySelector('span').textContent.trim() : cb.value;
                });
                const updateMatches = document.getElementById('teamEditMatches')?.checked;
                
                if (selectedIds.length === 0 && !updateMatches) {
                    HLL.showAlert('Nothing selected to update', 'error');
                    return;
                }
                
                const summary = [];
                if (selectedIds.length > 0) summary.push(`${selectedIds.length} player(s)`);
                if (updateMatches && matchCount > 0) summary.push(`${matchCount} match(es)`);
                
                const playerList = selectedNames.length > 0 ? `\n\nPlayers:\n${selectedNames.map(n => `  ‚Ä¢ ${n}`).join('\n')}` : '';
                if (!confirm(`Move ${summary.join(' and ')} from "${oldName}" ‚Üí "${dest}"?${playerList}`)) return;
                
                let errors = [];
                
                // Update selected players
                if (selectedIds.length > 0) {
                    const { error } = await HLL.supabase.from('players').update({ team: dest }).in('steam_id', selectedIds);
                    if (error) errors.push('Players: ' + error.message);
                }
                
                // Update matches
                if (updateMatches && matchCount > 0) {
                    const { error } = await HLL.supabase.from('matches').update({ my_team: dest }).eq('my_team', oldName);
                    if (error) errors.push('Matches: ' + error.message);
                }
                
                overlay.remove();
                
                if (errors.length > 0) {
                    HLL.showAlert('Some updates failed: ' + errors.join('; '), 'error');
                } else {
                    HLL.showAlert(`Moved ${summary.join(' and ')} ‚Üí "${dest}"`, 'success');
                    loadManagedTeams();
                }
            };
        }

        async function deleteMyTeam(teamName) {
            // Check current usage
            const { data: playersUsing } = await HLL.supabase.from('players').select('steam_id').eq('team', teamName);
            const { data: matchesUsing } = await HLL.supabase.from('matches').select('match_id').eq('my_team', teamName);
            const pc = playersUsing?.length || 0;
            const mc = matchesUsing?.length || 0;
            
            if (pc === 0 && mc === 0) {
                if (!confirm(`Delete "${teamName}"?`)) return;
                HLL.showAlert(`"${teamName}" removed.`, 'success');
                loadManagedTeams();
                return;
            }
            
            // Team is in use ‚Äî offer to migrate and delete
            if (!confirm(`"${teamName}" has ${pc} player(s) and ${mc} match(es).\n\nMigrate them to another team and delete "${teamName}"?`)) return;
            
            // Open the rename modal which handles migration
            renameMyTeam(teamName);
        }

        async function removeEnemyTeam(teamTag) {
            // Check if used in matches
            const { data: matchesUsing } = await HLL.supabase.from('matches').select('match_id').eq('enemy_team', teamTag);
            const matchCount = matchesUsing?.length || 0;
            
            let msg = `Remove "${teamTag}" from enemy teams?`;
            if (matchCount > 0) {
                msg = `"${teamTag}" appears in ${matchCount} match(es).\n\nThis will remove it from the enemy_teams table and the import dropdown, but won't delete match history.\n\nContinue?`;
            }
            if (!confirm(msg)) return;
            
            const { error } = await HLL.supabase.from('enemy_teams').delete().eq('team_tag', teamTag);
            if (error) {
                HLL.showAlert('Failed to remove: ' + error.message, 'error');
            } else {
                HLL.showAlert(`Removed "${teamTag}"`, 'success');
                loadManagedTeams();
            }
        }

        // Start
        init();
        loadMyTeamDivisions();
        loadManagedTeams();
    </script>
</body>
</html>
